-- MariaDB dump 10.19  Distrib 10.5.9-MariaDB, for debian-linux-gnu (x86_64)
--
-- Host: localhost    Database: chungchamchi
-- ------------------------------------------------------
-- Server version	10.5.9-MariaDB-1:10.5.9+maria~focal

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `article`
--

DROP TABLE IF EXISTS `article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `article` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) NOT NULL,
  `description` varchar(255) NOT NULL,
  `content` longtext DEFAULT NULL,
  `avatar` varchar(255) NOT NULL,
  `updatedAt` datetime NOT NULL,
  `createdAt` datetime NOT NULL,
  `isDeleted` tinyint(1) NOT NULL,
  `userId` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FK_636f17dadfea1ffb4a412296a28` (`userId`),
  CONSTRAINT `FK_636f17dadfea1ffb4a412296a28` FOREIGN KEY (`userId`) REFERENCES `user` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article`
--

LOCK TABLES `article` WRITE;
/*!40000 ALTER TABLE `article` DISABLE KEYS */;
INSERT INTO `article` VALUES (1,'first test','chung1999','chung dinh dep trai','haha','2021-04-21 02:17:08','2021-04-11 23:11:12',1,97),(2,'first test','chung1999','chung dinh dep trai','haha','2021-04-21 02:17:03','2021-04-11 23:12:44',1,97),(3,'first test','chung1999','chung dinh dep trai','haha','2021-04-21 02:16:59','2021-04-11 23:14:44',1,97),(4,'first test 1','chung1999','<p>chung dinh dep trai&nbsp;</p><p>Gấu chó xinh đẹp 2</p>','haha','2021-04-21 02:16:49','2021-04-12 00:00:47',1,97),(5,'chung test','chung1999','chung dinh dep trai','haha','2021-04-21 01:38:47','2021-04-12 10:46:56',1,11),(6,'chung test update','chung1999','chung dinh dep trai qua','haha','2021-04-21 10:39:19','2021-04-12 10:47:15',1,11),(7,'chung test update 121','chung1999','<p>chung dinh dep trai test update 112 aaaa ml tung ngu</p>','ml tung','2021-04-21 01:33:49','2021-04-12 11:07:48',1,11),(8,'Git - Học nghiêm túc một lần (Phần 1)','IoC Container','<h2 style=\"margin-left:0px;\"><strong>1. Mở đầu</strong></h2><p>Bạn là một <code>lập trình viên</code>:</p><ul><li>Đã bao giờ bạn vô tình làm các dòng code <code>rối tung</code> lên hay vô tình <code>xóa</code> các file đi và chương trình gặp lỗi.</li><li>Vậy làm sao để <code>hoàn nguyên</code> code về trạng thái cũ, chẳng nhẽ lúc nào cũng tạo bản <code>backup</code>, 10 lần backup là 10 bản.</li></ul><p>Bạn là một <code>lập trình viên</code>:</p><ul><li>Bạn tham gia trong một dự án, bạn muốn <code>cập nhật</code> sự thay đổi code của thành viên khác một cách nhanh chóng</li><li>Chẳng nhẽ cứ sao chép code vào <code>usb</code> rồi gửi cho nhau như hồi mới vào nghề.</li></ul><p>Quá bất tiện và dễ gây <code>sai sót</code>, nhu cầu đó thúc đẩy:</p><ul><li>Tạo ra công cụ giúp <code>quản lý phiên bản</code> của source code</li><li>Và từ đó, Hệ Thống Quản Lý phiên bản (Version Control System - VCS) ra đời.</li></ul><h2 style=\"margin-left:0px;\"><strong>2. Tiến hóa</strong></h2><p>Cùng đọc <code>lịch sử</code> chút nào:</p><p>Với vấn đề trên, từ lâu người ta đã xây dựng các phiên bản VCS <code>cục bộ</code>:</p><p>Chứa một database đơn giản.</p><p>Lưu trữ lại mọi sự thay đổi.</p><figure class=\"image\"><img src=\"https://viblo.asia/uploads/611c2af8-2b1b-4070-a7a1-0675b3ef80e1.png\" alt=\"\" srcset=\"https://viblo.asia/uploads/611c2af8-2b1b-4070-a7a1-0675b3ef80e1.png\" sizes=\"100vw\"></figure><p>Nhưng bài toán <code>kết nối</code> với các lập trình viên khác thì vẫn chưa giải được.</p><p>Vậy là <code>Hệ Thống Quản Lý Phiên Bản Tập Trung (Centralized Version Control Systems - CVCSs)</code> được phát triển, với một vài cái tên như <code>CVS, Subversion, và Perforce</code>.</p><p>Mô hình này bao gồm 01 máy chủ có chứa tất cả các file đã được <code>phiên bản hoá</code> kèm theo danh sách các máy khách có quyền thay đổi các tập tin này trên máy chủ trung tâm đó.</p><p>Trong một thời gian dài, mô hình này thực sự là <code>tiêu chuẩn</code> cho việc quản lý phiên bản.</p><figure class=\"image\"><img src=\"https://viblo.asia/uploads/cd075a32-c136-4b45-a72a-73be8d361b0d.png\" alt=\"\" srcset=\"https://viblo.asia/uploads/cd075a32-c136-4b45-a72a-73be8d361b0d.png\" sizes=\"100vw\"></figure><p>Nghe có vẻ đã ổn khi mà các thành viên trong team đã có thể kết nối với nhau nhưng có một vấn đề xảy ra.</p><ul><li>Đó là khi máy chủ gặp <code>sự cố</code>, các thành viên chẳng thể kết nối với nhau.</li><li>Nếu ổ cứng máy chủ bị hỏng, các bản sao lưu dự phòng của máy chủ chưa kịp backup thì thông tin sẽ bị thất thoát, thậm chí là <code>mất tất cả</code>.</li></ul><p>Đã tới lúc cần tới các <code>Hệ Thống Quản Lý Phiên Bản Phân Tán</code> - (Distributed Version Control Systems - DVCSs).</p><p>Trong các DVCS (ví dụ như <code>Git</code>, Mercurial, Bazaar hay Darcs) các máy khách sao chép toàn bộ kho chứa (repository)</p><p>Chính vì vậy, chúng ta luôn có những bản sao đầy đủ của tất cả dữ liệu</p><figure class=\"image\"><img src=\"https://viblo.asia/uploads/de65aef9-236b-46e8-845e-6bbbf22e9d64.png\" alt=\"\" srcset=\"https://viblo.asia/uploads/de65aef9-236b-46e8-845e-6bbbf22e9d64.png\" sizes=\"100vw\"></figure><p>Ngoài ra, DVCSs còn giải quyết được bài toán quản lý nhiều kho chứa từ xa, khi đó còn có thể cộng tác với nhiều nhóm người khác nhau theo những cách khác nhau trong cùng một dự án.</p><h2 style=\"margin-left:0px;\"><strong>3. Git - Sự kiện</strong></h2><p>Có thể bạn sắp biết, dự án phần mềm mã nguồn mở nhân của <code>Linux</code> có một phạm vi khá lớn.</p><ul><li>Kể từ năm 2002, dự án này sử dụng <code>BitKeeper</code> - một DVCS độc quyền.</li><li>Vào năm 2005 định mệnh đó, con thuyền giữa <code>cộng đồng phát triển nhân Linux</code> và <code>công ty thương mại phát triển BitKeeper</code> bị phá vỡ, và công cụ đó không còn được cung cấp miễn phí nữa.</li><li>Chính lý do này đã thúc đẩy cộng đồng phát triển Linux (chính xác hơn là Linus Torvalds, người sáng lập ra Linux) phát triển công cụ của riêng họ dựa trên những bài học từ việc sử dụng <code>BitKeeper</code>.</li><li>Và Git đã <code>ra đời</code> như vậy, một công cụ nhanh kinh ngạc, thiết kế đơn giản, phân tán toàn diện.</li><li>Có khả năng xử lý các dự án lớn giống như nhân Linux.</li><li>Mạnh mẽ và được đông đảo developer sử dụng.</li></ul><p>Giả sử như ngày xửa ngày xưa con thuyền <code>tình ái</code> giữa cộng đồng phát triển Linux và công ty thương mại phát triển BitKeeper không tan vỡ.</p><p>Thì giới coder bây chừ đâu có Git <code>ngon nghẻ</code> thế này mà sài free nhỉ.</p><p>Thế nên các bác nào mới chia tay gấu thì đừng buồn nha, biết đâu đó lại là <code>điềm lành</code>.</p><figure class=\"image\"><img src=\"https://viblo.asia/uploads/929a92a5-af4c-4abb-b0a5-8bdc5941eb3b.jpg\" alt=\"\" srcset=\"https://viblo.asia/uploads/929a92a5-af4c-4abb-b0a5-8bdc5941eb3b.jpg\" sizes=\"100vw\"></figure><h2 style=\"margin-left:0px;\"><strong>4. Git - Overview</strong></h2><figure class=\"image\"><img src=\"https://viblo.asia/uploads/35d653ea-c196-4eff-849c-675060680993.jpg\" alt=\"\" srcset=\"https://viblo.asia/uploads/35d653ea-c196-4eff-849c-675060680993.jpg\" sizes=\"100vw\"></figure><p>Nếu như bạn đã từng sử dụng Git thì chắc hẳn lắm lúc cũng đã từng <code>nóng gáy</code> để fix lỗi về Git.</p><p>Cho dù là lần đầu học về Git hay đã từng sử dụng, thiết nghĩ rằng bạn nên</p><ul><li>Hiểu rõ hơn <code>bản chất</code> của Git là gì</li><li>Các <code>nguyên tắc</code> cơ bản và <code>follow</code> làm việc của Git</li><li>Rồi sau đó mới nên học tới <code>các câu lệnh</code></li></ul><p>Khi học Git:</p><p>Hãy cố gắng gạt bỏ những kiến thức mà có thể bạn đã biết về các VCS khác, ví dụ như Subversion và Perforce; việc này sẽ giúp bạn tránh được sự hỗn độn, bối rối khi sử dụng nó.</p><p>Chung quy lại, các <code>câu lệnh</code> dù rất nhiều nhưng cũng chỉ <code>biến tấu</code> từ những điều cơ bản mà ra. Nắm <code>phần gốc</code> là sẽ làm chủ được <code>phần ngọn</code>, bằng không, chúng ta sẽ nhớ câu lệnh khá khổ sở và sau này có gặp bug cũng chẳng biết phải fix kiểu gì (vì chẳng hiểu bản chất nó tại sao lại thế).</p><p>Chỉ lên <code>google search</code> vài câu lệnh cơ bản như <code>add, commit, pull, push, merge, rebase,...</code> rồi chạy thì không ổn, sẽ như kiến bò trên chảo nóng sớm thui à (Hình ảnh của mình hồi năm 3 đại học).</p><ul><li>Dưới đây là hình ảnh trang chủ của <a href=\"https://git-scm.com/\">Git</a><ul><li>Có <code>4</code> mục lớn bao gồm <code>About</code>, <code>Documentation</code>, <code>Downloads</code> và <code>Community</code>.</li><li>Nếu như bạn đọc, hiểu rõ và thực hành hết tất cả những điều nói trong trang này thì xin chúc mừng, bạn sẽ trở thành <code>master</code> Git sớm thôi.</li><li>Còn phạm vi bài viết sẽ tập trung vào phần <code>About</code> và <code>Document</code></li><li>Sau đây mình xin tóm lược những điều <code>cơ bản</code> về Git kèm theo một vài kinh nghiệm khi sử dụng Git mà mình đã tích lũy</li><li>Hi vọng sẽ giúp các bạn <code>dễ dàng tiếp cận</code> hơn và cảm thấy <code>thư thái</code> hơn khi sài Git.</li></ul></li></ul><figure class=\"image\"><img src=\"https://viblo.asia/uploads/55665a40-2666-48a5-ad28-b9c087bf27cd.png\" alt=\"\" srcset=\"https://viblo.asia/uploads/55665a40-2666-48a5-ad28-b9c087bf27cd.png\" sizes=\"100vw\"></figure><h2 style=\"margin-left:0px;\"><strong>5. Git - About</strong></h2><p>Điểm khác nhau cơ bản giữa <code>Git</code> với các <code>VCS</code> khác là cách Git <code>nghĩ</code> về dữ liệu.</p><p>Phần lớn hệ thống khác lưu thông tin dưới dạng</p><ul><li>Các tập tin được thay đổi,</li><li>Coi thông tin được lưu trữ như là một tập hợp các tập tin</li><li>Các thay đổi được thực hiện trên mỗi tập tin theo thời gian.</li></ul><p>Còn Git sẽ xem dữ liệu của mình giống như</p><ul><li>Một tập hợp các \"ảnh\" (snapshot) của một hệ thống tập tin.</li><li>Mỗi lần bạn lưu lại trạng thái hiện tại của dự án, về cơ bản Git \"chụp một bức ảnh\" ghi lại nội dung của tất cả các tập tin tại thời điểm đó và tạo ra một tham chiếu tới \"ảnh\" đó.</li><li>Để hiệu quả hơn, nếu như tập tin không có sự thay đổi nào, Git không lưu trữ tập tin đó lại một lần nữa mà chỉ tạo một liên kết tới tập tin gốc đã tồn tại trước đó.</li></ul><p>Còn đây là cách Git <code>làm</code> với dữ liệu</p><ul><li>Git chỉ thêm mới dữ liệu<ul><li>Dữ liệu của repository sẽ được lưu trong thư mục <code>.git</code>.</li><li>Khi bạn thực hiện các thao tác trong Git, phần lớn các hành động đó đều được thêm vào cơ sở dữ liệu của Git.</li><li>Rất khó để yêu cầu hệ thống thực hiện một hành động nào đó mà không thể khôi phục lại được hoặc xoá dữ liệu đi dưới mọi hình thức.</li><li>Giống như trong các VCS khác, bạn có thể mất hoặc làm rối tung dữ liệu mà bạn chưa commit; nhưng khi bạn đã commit thì rất khó để mất các dữ liệu đó, đặc biệt là nếu bạn thường xuyên đẩy (push) cơ sở dữ liệu sang một kho chứa khác.</li><li>Bạn có thể thoải mái thử nghiệm mà không lo sợ sẽ phá hỏng mọi thứ.</li></ul></li></ul><p>Dựa trên phần thiết kế lõi này, Git có những ưu điểm vượt bậc khác, cùng tìm hiểu dần nhé !</p><p>Git ưu ái dành phần đầu tiên: <code>About</code> này để giới thiệu và khoe ra điểm mạnh của mình.</p><p>Mà cái gì cũng thế, cứ phải thấy được điều tốt đẹp của nó thì mới có động lực để tìm hiểu</p><p>Kiểu như gặp bạn nữ xinh xắn đáng eo thì mới có động lực để theo đuổi vậy.</p><figure class=\"image\"><img src=\"https://viblo.asia/uploads/68e197c5-f8a2-4602-be5e-5f5162193e70.png\" alt=\"\" srcset=\"https://viblo.asia/uploads/68e197c5-f8a2-4602-be5e-5f5162193e70.png\" sizes=\"100vw\"></figure><p><code>-&gt; Branching and Merging</code></p><ul><li>Tìm hiểu cái này trước đã nhé ! Thế nào là <code>repository</code></li></ul><p><code>Repository</code> (hay gọi tắt là repo) được hiểu đơn giản là một kho chứa <code>toàn bộ project</code> bao gồm source code và lịch sử thay đổi cũng như nội dung thay đổi của từng file và từng cá nhân đóng góp cho project đó, gồm 2 loại là:</p><ul><li><code>Remote repository</code>: Kho này dùng để chia sẻ cho nhiều người và được đặt trên server chuyên dụng.</li><li><code>Local repository</code>: Kho này được đặt trên máy của bạn và chỉ dành cho một người mà thôi.</li></ul><p><code>Branch</code> là nhánh của repository:</p><ul><li>Các nhánh sẽ <code>độc lập</code> với nhau và phát triển một <code>tính năng</code> hoặc làm 1 nhiệm vụ nào đó, không gây ảnh hưởng đến các nhánh khác.</li><li>Khi các nhánh hợp nhất lại với nhau thì gọi là <code>merge</code>, thông thường, nhánh mặc định là <code>master</code>.</li><li>Branch ở trên local repo thì gọi là <code>local branch</code>.</li><li>Branch ở trên remote repo thì gọi là <code>remote branch</code>.</li><li>Một <code>branch trên local</code> có thể liên kết với 1 hoặc nhiều <code>branch trên remote</code> hoặc không branch nào cả.</li><li>Git cho phép và khuyến khích bạn tạo nhiều <code>branch tại máy tính cá nhân</code> của bạn, việc tạo, sáp nhập và xóa bỏ những branch này diễn ra rất nhanh chóng.</li><li>Thông thường thì branch master chứa phiên bản code chạy <code>ngon ngẻ nhất</code> để deploy lên production,</li><li>Branch dev để bạn có thể <code>kiểm thử</code> lại chức năng</li><li>Một vài branch nhỏ để xây dựng các <code>tính năng mới</code>.</li><li>Sau khi viết code để thực hiện chức năng mới ở branch nhỏ xong, bạn hợp nhất (<code>merge</code>) code vào branch dev, tiến hành kiểm thử, nếu ok thì tiếp tục <code>merge</code> code từ dev vào master.</li><li>Việc chuyển đổi trạng thái code từ branch này sang branch khác hoàn toàn dễ dàng, nếu như chức năng mới của bạn bị lỗi, bạn hoàn toàn có thể xóa branch đó đi mà chẳng gây <code>ảnh hưởng</code> những chức năng khác,</li><li>Follow cơ bản là vậy, trong dự án thì có thể tùy biến ít nhiều.</li></ul><p><code>-&gt; Small and Fast</code></p><p>Git chứng tỏ rằng mình rất nhẹ và hoạt động nhanh chóng vì những lí do sau:</p><ul><li>Gần như tất cả các hoạt động được thực hiện tại máy tính <code>cá nhân</code> nên Git có một lợi thế tốc độ rất lớn so với các hệ thống mà liên tục phải <code>giao tiếp</code> với một máy chủ ở đâu đó.</li><li>Git được viết bằng <code>C</code>, làm giảm tổng phí thời gian chạy liên quan đến ngôn ngữ cấp cao hơn.</li><li>Ban đầu Git được xây dựng để làm việc trên hạt nhân Linux, <code>tốc độ</code> và <code>hiệu suất</code> là một mục tiêu thiết kế chính của Git ngay từ đầu.</li><li>Họ có dẫn ra một vài <code>biểu đồ</code> để so sánh Git với SVN, gọi là có chút số liệu để tăng tính thuyết phục (cột bé hơn thể hiện là nhanh hơn)</li></ul><p><code>-&gt; Distributed: Phân phối</code></p><p><code>Backup:</code> Một trong những tính năng hấp dẫn nhất của bất kỳ DSCM nào, trong đó có Git,</p><ul><li>Mỗi người dùng đều có thể tạo một bản <code>sao lưu</code> đầy đủ dữ liệu trên máy chủ chính về máy tính <code>cá nhân</code> của mình, gọi hành động này gọi là <code>clone</code>.</li><li>Mỗi bản sao này có thể được đẩy lên (<code>push</code>) để thay thế máy chủ chính trong trường hợp rủi ro nào đó hoặc có thể liên tục cập nhật (<code>pull</code>) về những thay đổi từ máy chủ mọi lúc.</li></ul><p>Chúng ta sẽ nói tới 2 <code>workflow</code> làm việc với Git thông dụng nhất:</p><ul><li><code>Subversion-Style:</code></li></ul><p>Tạm dịch là <code>kiểu lật đổ</code>, minh họa như hình bên dưới</p><p>Developer <code>clone</code> shared repository về máy của mình, cập nhật code</p><p>Sau đó <code>add</code>, <code>commit</code> rồi <code>push</code> lên shared repository.</p><ul><li>Mỗi một commit sẽ đính kèm theo một <code>message</code> mô tả sự thay đổi của code, tức là chú thích bạn vừa thay đổi gì.</li><li>Như vậy mỗi khi bạn commit thì Git sẽ nhận <code>code thay đổi</code> và <code>message mô tả ngắn gọn</code> sự thay đổi đó.</li><li>Mỗi một lần <code>commit</code> là một lần <code>lưu lại trạng thái</code> của code dưới local.</li><li>Còn để người khác có thể nhìn thấy được sự thay đổi đó thì cần <code>push</code> lên server.</li></ul><p>Lưu ý là Git sẽ không cho phép bạn <code>push</code> lên máy chủ nếu ai đó đã push <code>trong khoảng thời gian</code> từ lần cuối cùng bạn <code>pull</code> về trở đi.</p><p>Khi đó bạn cần phải <code>pull</code> về, kiểm tra lại, <code>add</code>, <code>commit</code> rồi mới <code>push</code> lên.</p><figure class=\"image\"><img src=\"https://viblo.asia/uploads/5d2f12f7-6ba7-48f5-a503-4660eec3dab0.png\" alt=\"\" srcset=\"https://viblo.asia/uploads/5d2f12f7-6ba7-48f5-a503-4660eec3dab0.png\" sizes=\"100vw\"></figure><p><code>Integration Manager</code></p><ul><li>Tạm dịch là <code>tích hợp quản lý</code>, kiểu này hịn và chuyên nghiệp hơn.</li><li>Nhưng <a href=\"https://git-scm.com/about/distributed\">hình ảnh trên trang chủ của Git</a> mô tả hơi khó hiểu, mình tạm chế nhanh ra từ bức ảnh bên, vẽ online cho nhanh, nhìn cũng xấu phết, kaka.</li></ul><p>\"Sao chép\" repository về kho của mình, gọi là <code>fock repo</code></p><p><code>Clone</code> fock repo từ kho về máy tính cá nhân.</p><p>Sau khi chỉnh sửa, <code>push</code> trạng thái mới lên fock repo.</p><p>Tạo bản so sánh giữa 2 branch của 2 repo, gọi là <code>pull request</code>, gửi cho người quản lý có quyền merge code mới vào, sẽ có demo sau.</p><figure class=\"image\"><img src=\"https://viblo.asia/uploads/9aca83cb-d1e3-40ca-8247-386b05ce7cd3.png\" alt=\"\" srcset=\"https://viblo.asia/uploads/9aca83cb-d1e3-40ca-8247-386b05ce7cd3.png\" sizes=\"100vw\"></figure><p><code>-&gt; Data Assurance</code></p><ul><li>Git đảm bảo tính toàn vẹn của dữ liệu.</li></ul><p>Mọi thứ trong Git được \"băm\" (checksum or hash) trước khi lưu trữ và được tham chiếu tới bằng mã băm đó.</p><p>Có nghĩa là việc thay đổi nội dung của một tập tin hay một thư mục mà Git không biết tới là điều không thể.</p><p>Chức năng này được xây dựng trong Git ở tầng thấp nhất, bạn không thể mất thông tin/dữ liệu trong khi truyền tải hoặc nhận về một tập tin bị hỏng mà Git không phát hiện ra.</p><p>Cơ chế mà Git sử dụng cho việc băm này được gọi là mã băm SHA-1. Đây là một chuỗi được tạo thành bởi 40 ký tự của hệ cơ số 16 (0-9 và a-f) và được tính toán dựa trên nội dung của tập tin hoặc cấu trúc thư mục trong Git.</p><p><code>-&gt; Staging Area</code> :</p><p>Đây là một khu vực trung gian mà commit có thể được định dạng và xem lại trước khi hoàn thành.</p><p>Mỗi tập tin trong Git được quản lý dựa trên ba trạng thái: committed, modified, và staged.</p><ul><li>Staged là bạn đã đánh dấu sẽ commit phiên bản hiện tại của một tập tin đã chỉnh sửa trong lần commit sắp tới.</li><li>Modified có nghĩa là bạn đã thay đổi tập tin nhưng chưa commit vào cơ sở dữ liệu.</li><li>Committed có nghĩa là dữ liệu đã được lưu trữ một cách an toàn trong cơ sở dữ liệu.</li></ul><figure class=\"image\"><img src=\"https://viblo.asia/uploads/9da95089-f428-4ceb-aa40-9c8587e9f6b2.png\" alt=\"\" srcset=\"https://viblo.asia/uploads/9da95089-f428-4ceb-aa40-9c8587e9f6b2.png\" sizes=\"100vw\"></figure><p>Nôm na như này:</p><ul><li>Các file mà chưa được add vào staging area thì Git nó hông quan tâm, chỉ khi nào bạn dùng lệnh add, chuyển file vào staging area thì nó mới quản lý.</li><li>Khi bạn commit file nào thì file đó được chuyển từ staging area vào repo.</li></ul><p><code>-&gt; Free and Open Source</code></p><p><code>-&gt; Trademark</code></p><p>Hai phần này mình bỏ ngỏ nhé !</p><h2 style=\"margin-left:0px;\"><strong>6. Git - Documentation</strong></h2><p>Hình ảnh bên dưới là trang documentation của Git, gồm 4 phần:</p><p><code>Reference</code>: Giới thiệu rất chi tiết từng câu lệnh của Git.</p><p><code>Book</code>: Phần này giới thiệu nội dung cuốn Pro Git, nếu đọc hết cuốn này thì bạn sẽ cứng kịa về Git rồi đó.</p><p><code>Video</code>: Một vài video tham khảo</p><p><code>External Links</code>: Một vài liên kết có liên quan.</p><figure class=\"image\"><img src=\"https://viblo.asia/uploads/6b4f6ecf-6d8f-4ba1-8742-e91eba25fce4.png\" alt=\"\" srcset=\"https://viblo.asia/uploads/6b4f6ecf-6d8f-4ba1-8742-e91eba25fce4.png\" sizes=\"100vw\"></figure><p>Nhưng chúng ta sẽ không đi theo follow trên</p><p>Để ngắn gọn và đơn giản hơn, thì lần lượt sẽ là:</p><h3 style=\"margin-left:0px;\"><strong>6.1 Cài đặt Git</strong></h3><p>Cũng không khó khăn lắm, các bạn tham khảo ở mục <a href=\"https://git-scm.com/downloads\">download</a> trên trang chủ của Git nhé !</p><h3 style=\"margin-left:0px;\"><strong>6.2 Tools</strong></h3><p><code>Tools:</code></p><ul><li>Thuần túy nhất thì các bạn làm việc với <code>command line</code> trên <code>Terminal</code> của <code>Linux</code> hoặc <code>Cmd</code> của <code>Windows</code>.</li><li>Bên cạnh đó thì có <a href=\"https://git-scm.com/downloads/guis\">các GUI hỗ trợ</a> như SourceTree, Git Desktop; một số editor như PHP storm hoặc Ruby Mine cũng có tích hợp.</li><li>Ngày mới ban đầu tiếp cận với Git thì mình dùng GUI và chúa ghét bác nào dùng command line.</li><li>Kiểu ra vẻ, thích tỏ ra nguy hiểm, đã có GUI để thao tác click chuột trên cho đơn giản, tiết kiệm thời gian rồi mà còn bày đặt.</li><li>Nhưng bây chừ thì mình chỉ dùng command line, cảm thấy khi đó mình sẽ hiểu rõ bản chất vấn đề hơn, tùy biến được nhiều hơn, giải quyết mọi thứ theo ý mình. GUI thì nó cũng base từ command mà ra.</li><li>Hôm nọ mình làm cùng dự án với ông anh, thấy mình dùng Git trên command line, anh ấy bảo mình vài câu, đại ý cũng như mình hồi còn dùng Git trên GUI, mình chỉ lặng cười nhẹ thôi, biết nói gì bây chừ.</li><li>Kể ra thì đôi khi cũng có nhiêu cái hay, gặp điều gì mình không thích thì cũng phản ứng bình từ thôi, có thể có lý do nào đấy.</li></ul><p><code>Server:</code></p><ul><li>Có một số nhà cung cấp như GitHub, BitBucket, GitLab.</li><li>Cá nhân thì mình và phần lớn đồng nghiệp đều thấy GitHub hỗ trợ người dùng tốt nhất, chức năng ổn định, giao diện dễ nhìn, thao tác đơn giản.</li><li>Sau đây, mình sẽ hướng dẫn các bạn làm việc với <code>command line</code> trên Ubuntu và sử dụng <code>server GitHub</code> nhé.</li><li>Có một lưu ý là nếu dùng <code>command line</code> trên Ubuntu thì bạn nên cài Zsh, tối ưu nó một chút, cài thêm plugin <code>auto_suggest</code> để thuận tiện hơn, tham khảo bài viết của mình tại <a href=\"https://viblo.asia/p/bot-lay-loi-hieu-ro-hon-toi-uu-su-dung-phim-tat-cho-terminal-ORNZqowM50n\">đây</a></li></ul><h3 style=\"margin-left:0px;\"><strong>6.3 SSH key</strong></h3><p>Với Git, nếu bạn sử dụng giao thức HTTPS để truyền tải dữ liệu giữa server và client thì mỗi lần bạn pull hay push đều cần phải nhập lại email và mật khẩu GitHub, vậy hãy dùng giao thức SSH như sau:</p><p>Gõ câu lệnh sau vào Terminal:</p><p><code>ssh-keygen -t rsa -C \"hoanki2212@gmail.com\"</code></p><figure class=\"image\"><img src=\"https://viblo.asia/uploads/eeb72f78-de2d-42ef-ae76-9c590fe120a6.png\" alt=\"\" srcset=\"https://viblo.asia/uploads/eeb72f78-de2d-42ef-ae76-9c590fe120a6.png\" sizes=\"100vw\"></figure><ul><li>Câu lệnh trên sẽ sinh ra một <code>public key</code> và một <code>private key</code><ul><li><code>Private key</code> thì tuyệt đối đừng chia sẻ</li><li><code>Public key</code> thì share nó với github.</li></ul></li><li>Bạn sẽ thấy dòng chữ: <code>Your public key has been saved in:</code> + path. Theo path đó, mở file và copy public key.</li><li>Đăng nhập vào GitHub -&gt; Setting -&gt; <a href=\"https://github.com/settings/keys\">SSH and GPG keys</a> -&gt; <a href=\"https://github.com/settings/ssh/new\">Add new SSH key</a></li><li>Điền public key và nhấp okie, từ giờ bạn có thể dùng giao thức SSH được rồi.</li></ul><h3 style=\"margin-left:0px;\"><strong>Updating ...</strong></h3><p>Phần 1 này chủ yếu giới thiệu về lý thuyết:</p><ul><li>Để mình cùng nhau hiểu hơn Git là gì và bản chất của phần mềm này đã.</li><li>Trong quá trình viết bài mình cần tìm hiểu thêm nhiều và cũng nhận ra nhiều điều mới.</li><li>Nếu có ý kiến đóng góp gì, bạn vui lòng comment bên dưới nhé !</li></ul><p>Trong phần 2 chúng ta sẽ:</p><ul><li>Cùng tìm hiểu rõ hơn các câu lệnh.</li><li>Và áp dụng Git vào dự án thực tế như thế nào nhé.</li></ul><p>###############################################</p>','https://nukeviet.edu.vn/uploads/news/2021_01/1-tnsfds-deye722crqxjv8w.png','2021-04-21 00:23:38','2021-04-18 00:42:48',0,11),(9,'Docker: Chưa biết gì đến biết dùng (Phần 4 - Một số trick tối ưu và lưu ý)','IoC Container','<h2 style=\"margin-left:0px;\"><strong>1. Mở đầu</strong></h2><ul><li>Chào các bạn, sau khi đi qua ba phần đầu của series: <code>Docker - Chưa biết gì đến biết dùng</code></li><li>Chúng ta đã tìm hiểu vai trò, cách sử dụng <code>Dockerfilke</code> &amp;&amp; <code>docker-compose.yml</code> để ứng dụng <code>Docker</code> vào trong dự án.</li></ul><figure class=\"image\"><img src=\"https://images.viblo.asia/48deb81c-a4bd-4294-9202-266cc90b2f18.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/48deb81c-a4bd-4294-9202-266cc90b2f18.png 2x\" sizes=\"100vw\"></figure><p>Hôm nay, chúng ta sẽ tiếp tục tìm hiểu một số cách để <code>tối ưu</code> công cụ này nhé !</p><p>Bài viết tiếp tục dựa trên <code>Rails framework</code> để tìm hiểu, nhưng tác giả sẽ cố gắng để viết tổng quát vấn đề.</p><h2 style=\"margin-left:0px;\"><strong>2. Docker-compose up</strong></h2><p>Sau khi chúng ta gõ <a href=\"https://docs.docker.com/compose/reference/up/\">docker-compose up</a> thì</p><p>Câu lệnh này sẽ <code>pull</code> / <code>build</code> tất cả cả các <code>images</code> mà chúng ta đã định nghĩa</p><p>Trong trường hợp máy đã <code>có sẵn</code> image thì sẽ được skip bước này</p><figure class=\"image\"><img src=\"https://images.viblo.asia/373824de-9ca1-4126-a76e-b54cc0e549c7.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/373824de-9ca1-4126-a76e-b54cc0e549c7.png 2x\" sizes=\"100vw\"></figure><p>Tiếp theo là <code>run image</code> và <code>create container</code>.</p><figure class=\"image\"><img src=\"https://images.viblo.asia/1d627995-28cc-4405-9e4c-26898f1ea68c.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/1d627995-28cc-4405-9e4c-26898f1ea68c.png 2x\" sizes=\"100vw\"></figure><p>Rồi đính kèm chúng với các <code>service</code> tương ứng (Luôn nhớ rằng mỗi <code>container</code> ứng với một máy ảo)</p><p>Câu lệnh này sẽ tổng hợp <code>logs</code> của tất cả các <code>container</code> và hiển thị lên <code>Terminal</code></p><p>Ở <a href=\"https://github.com/HoanKy/docker_tutorial/tree/rails\">đây</a> có <code>mysql service</code> và <code>app service</code> nên có <code>logs</code> của 2 bác này, màu hiển thị cũng khác nhau cho chúng ta dễ phân biệt.</p><figure class=\"image\"><img src=\"https://images.viblo.asia/9cafeb3b-a420-450d-9f53-09a73550493d.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/9cafeb3b-a420-450d-9f53-09a73550493d.png 2x\" sizes=\"100vw\"></figure><p>Khi muốn tắt <code>service</code> thì nhấn tổ hợp phím <code>Ctrl + C</code></p><figure class=\"image\"><img src=\"https://images.viblo.asia/026d6812-0d03-49cb-a57a-62ce2096f327.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/026d6812-0d03-49cb-a57a-62ce2096f327.png 2x\" sizes=\"100vw\"></figure><p>Nếu như bạn dùng <code>docker-compose up -d</code> thì các <code>containers</code> sẽ chạy ngầm, màn hình <code>Terminal</code> sẽ không hiển thị <code>logs</code></p><figure class=\"image\"><img src=\"https://images.viblo.asia/3c6f738b-07e8-4ff7-9d1d-cbf268ddc76c.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/3c6f738b-07e8-4ff7-9d1d-cbf268ddc76c.png 2x\" sizes=\"100vw\"></figure><hr><p>Với cách triển khai này thì có chút nhược điểm như sau:</p><p>Như bạn thấy ở trên, khi <code>Ctrl + C</code> thì sẽ tắt tất cả <code>service</code>,</p><p>Khi <code>docker-compose up</code> thì lại bật tất cả chúng lên.</p><p>Cứ tắt bật, tắt bật tất cả <code>service</code> liên tục như thế, trong project này chỉ có 2 <code>service</code> nên có vẻ chưa hề hấn gì nhưng nếu số lượng <code>service</code> lớn hơn (ví dụ <code>mysql</code> + <code>redis</code> + <code>nginx</code> ....) thì cũng mất kha khá thời gian đấy.</p><p>Hơn nữa, khi chúng ta debug code trên Terminal, kiểu như thế này</p><figure class=\"image\"><img src=\"https://images.viblo.asia/fd541956-bfc7-47fc-9c04-2d8293327ebc.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/fd541956-bfc7-47fc-9c04-2d8293327ebc.png 2x\" sizes=\"100vw\"></figure><p>Thì <code>docker-compose up</code> sẽ không dừng hiển thị <code>logs</code> để chúng ta <code>kiểm tra giá trị</code> của các biến chẳng hạn,</p><p>Mà bỏ qua một cách lạnh lùng, như thế này.</p><figure class=\"image\"><img src=\"https://images.viblo.asia/7e189d7a-c7eb-4212-8aeb-806277b46ded.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/7e189d7a-c7eb-4212-8aeb-806277b46ded.png 2x\" sizes=\"100vw\"></figure><p>Bởi vì <code>docker-compose up</code> hiển thị <code>logs</code> tổng hợp của tất cả <code>service</code></p><p>Không vì một <code>service</code> nào mà dừng lại cả, như vậy là chúng ta không <code>debug</code> được.</p><hr><p><code>-&gt; Giải pháp là gì ?</code></p><p>Thay vì bật tất cả <code>containers</code> lên cùng một lúc</p><p>Chúng ta sẽ bật các <code>background containers</code> lên trước (ví dụ: mysql, redis ...)</p><p>Sau đó mới bật <code>main container</code> (ví dụ: app).</p><p>Khi stop thì ta chỉ stop <code>main container</code> thôi, các <code>background containers</code> vẫn chạy ngầm bên dưới.</p><p>Câu lệnh</p><p>Start background container( chỉ 1 lần khi mới mở máy tính lên )</p><pre><code class=\"language-plaintext\"> docker-compose up -d mysql \n docker-compose up -d redis\n docker-compose up -d woker \n</code></pre><p>Start main container</p><pre><code class=\"language-plaintext\"> docker-compose run --rm -p 3000:3000 app rails s\n</code></pre><h2 style=\"margin-left:0px;\"><strong>3. Makefile</strong></h2><ul><li>Phải công nhận là gõ những dòng <code>docker-compose up -d ...</code> nhiều như vậy thật là mệt.</li></ul><figure class=\"image\"><img src=\"https://images.viblo.asia/bd1e63a7-fec6-4522-98c0-fd86f7a64c38.gif\" alt=\"\" srcset=\"https://images.viblo.asia/retina/bd1e63a7-fec6-4522-98c0-fd86f7a64c38.gif 2x\" sizes=\"100vw\"></figure><p>Chưa kể <code>docker-compose build</code>, <code>up</code> rồi <code>down</code>, <code>run</code> ...</p><p>Vậy thì hãy dùng <a href=\"https://www.google.com/search?newwindow=1&amp;ei=dGHnXKL9CNOvoASssrrQAw&amp;q=what+is+makefile&amp;oq=what+is+makefile&amp;gs_l=psy-ab.3..0j0i7i30l9.5372.10460..10962...8.0..0.100.1267.14j1......0....1..gws-wiz.......0i71j35i39j35i304i39j0i13j0i19j0i13i30i19j0i8i13i30i19j0i13i30.Nb1soXCxWms\">Makefile</a>, công dụng của nó thì có nhiều hơn nhưng ở đây mình chỉ ứng dụng nôm na giống như <a href=\"https://viblo.asia/p/hieu-ro-hon-toi-uu-va-su-dung-phim-tat-cho-terminal-ORNZqowM50n#_5-tao-alias-trong-terminal-12\">Git alias</a> vậy, không cần phải ghi nhớ và gõ nhiều câu lệnh.</p><p>Thay vì phải gõ từng câu lệnh một</p><pre><code class=\"language-plaintext\">docker-compose up -d mysql \ndocker-compose up -d redis\ndocker-compose up -d worker \n</code></pre><p>hoặc ngắn hơn</p><pre><code class=\"language-plaintext\">docker-compose up -d mysql redis worker\n</code></pre><p>thì hãy viết vào trong Makefile:</p><pre><code class=\"language-plaintext\">up:\n   docker-compose up -d mysql redis worker\n</code></pre><p>và</p><pre><code class=\"language-plaintext\">dev: \n    docker-compose run --rm -p 3000:3000 app rails s\n</code></pre><p>Khi đó, trên Terminal gõ <code>make up</code> để start các <code>background containers</code>, sau đó gõ <code>make dev</code> để start <code>main container</code></p><p>Mình có push code mẫu lên <a href=\"https://github.com/HoanKy/docker_tutorial/blob/rails_mysql_optimum/Makefile#L22\">GitHub</a></p><p>Hơn nữa, khi có một member mới vào dự án và chưa rõ về Docker (có thể là member của team front end chẳng hạn), khi support setup project, bạn chỉ cần <a href=\"https://github.com/HoanKy/docker_tutorial/tree/rails_mysql_optimum#use-docker-for-development\">hướng dẫn</a>.</p><ul><li>Chạy <code>make up</code> để bật các tiến trình nền.</li><li>Chạy <code>make dev</code> để start project.</li><li>Chạy <code>make test</code> để test code trước khi gửi pull request.</li></ul><p>Mà bản thân họ không cần phải có quá nhiều kiến thức về Docker, khá là tiện lợi phải không</p><figure class=\"image\"><img src=\"https://images.viblo.asia/9ba52ce7-d018-485c-b69b-7b134ecee5fb.jpg\" alt=\"\" srcset=\"https://images.viblo.asia/retina/9ba52ce7-d018-485c-b69b-7b134ecee5fb.jpg 2x\" sizes=\"100vw\"></figure><h2 style=\"margin-left:0px;\"><strong>3. Depends_on &amp;&amp; links</strong></h2><ul><li>Ở một số <a href=\"https://docs.docker.com/compose/rails/\">hướng dẫn</a>, chúng ta có thể nhìn thấy sử dụng <a href=\"https://docs.docker.com/compose/compose-file/#depends_on\">depends_on</a> &amp; <a href=\"https://docs.docker.com/compose/compose-file/#links\">links</a>, ví dụ:</li></ul><pre><code class=\"language-plaintext\">  app:\n    build: .\n    container_name: app\n    depends_on:\n      - mysql\n      - redis\n</code></pre><p>hoặc</p><pre><code class=\"language-plaintext\">  app:\n    build: .\n    container_name: app\n    links:\n      - mysql\n      - redis\n</code></pre><p><code>depends_on</code> và <code>links</code> được dùng để thể hiện sự phụ thuộc giữa các <code>service</code>, nó tạo ra các hành vi:</p><ul><li><code>docker-compose up</code> sẽ khởi động các <code>service</code> theo thứ tự phụ thuộc, ở đây sẽ là khởi động <code>mysql</code> và <code>redis</code> trước.</li><li><code>docker-compose up app</code> - tức là khi bạn chỉ khởi động 1 service đơn lẻ thì service <code>mysql</code> và <code>redis</code> vẫn sẽ được khởi động.</li></ul><p><a href=\"https://stackoverflow.com/a/39658359\">Sự khác nhau giữa hai đồng chí này</a>, thậm chí <a href=\"https://docs.docker.com/compose/compose-file/#links\">links</a> cuối cùng có thể được gỡ bỏ, thay vào đó các service nằm trong cùng một network thì có thể tự tìm thấy nhau.</p><p>Thì đấy, bạn có thể giải quyết <a href=\"https://viblo.asia/p/docker-chua-biet-gi-den-biet-dung-phan-3-docker-compose-3P0lPm6p5ox#_note-11\">vấn đề này</a> bằng cách sử dụng <code>depends_on</code> nhưng nhược điểm thì đã nên ở trên, cứ bật lên tắt xuống mất khá nhiều thời gian, trong thực tế <code>service mysql</code> có thể mất tới gần 20s để khởi động.</p><p>Thậm chí khi <code>mysql container</code> đã chạy sẵn mà bạn <code>run container app</code> lên thì Docker vẫn tạo mới một <code>mysql container</code> nữa chứ không sử dụng <code>mysql container</code> đó.</p><h2 style=\"margin-left:0px;\"><strong>4. CMD &amp;&amp; entrypoint</strong></h2><h2 style=\"margin-left:0px;\"><strong>5. Layers và images</strong></h2><p><code>Docker image</code> được xây dựng dựa trên các <code>layers</code> xếp chồng, giống như việc bạn xếp nhiều viên gạch chồng lên nhau vậy.</p><p>Cùng xem cách Docker build image</p><figure class=\"image\"><img src=\"https://images.viblo.asia/54faf26c-2c3b-4c77-bf87-a878d94b80b2.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/54faf26c-2c3b-4c77-bf87-a878d94b80b2.png 2x\" sizes=\"100vw\"></figure><p><code>mysql uses an image, skipping</code>: Container mysql sử dụng image có sẵn bên không cần build image nữa -&gt; <code>skipping</code></p><p><code>Building app</code>: Bắt đầu build image cho <code>container app</code>.</p><p><code>Step 1/15</code>, <code>Step 2/15</code>, <code>Step 3/15</code> ... Từng câu lệnh trong <code>Dockerfile</code> sẽ được thực thi và sẽ tạo ra các <code>layers</code> tương ứng.</p><p>Nếu câu lệnh trước đó đã được thực thi và tạo <code>layer</code> thì Docker sẽ sử dụng <code>layer</code> cũ đó chứ không tạo <code>layer</code> mới nữa, giúp <code>giảm thời gian</code> build image và nếu ở một <code>layer</code> có sự thay đổi thì kể từ layer đó trở về sau, tất cả sẽ được build lại.</p><p>Dùng <code>docker images -a</code> để kiểm ra danh sách các images nhé.</p><figure class=\"image\"><img src=\"https://images.viblo.asia/b31445f2-1123-4f74-a3d8-07df1ba6ca28.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/b31445f2-1123-4f74-a3d8-07df1ba6ca28.png 2x\" sizes=\"100vw\"></figure><blockquote><p>Oài, sao nhiều <code>none image</code> vậy ? Chúng là gì, sao dung lượng của chúng lớn vậy ? Nó sẽ tiêu thụ nhiều không gian ổ cứng à ?</p></blockquote><ul><li>Thực ra <code>none image</code> chính là những <code>layers</code>, hãy xem cách Docker pull images về như thế nào.</li></ul><figure class=\"image\"><img src=\"https://images.viblo.asia/87c80422-d1ae-4c53-bb45-983a62855606.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/87c80422-d1ae-4c53-bb45-983a62855606.png 2x\" sizes=\"100vw\"></figure><p>Cũng tương tự như khi chúng ta <code>build image</code> vậy, từng <code>layer</code> được xây dựng theo mô hình cha con, sinh sau đẻ muộn hơn thì là <code>layer con</code>, kế thừa từ <code>layer cha</code>, tất cả đều được đặt tên là <code>&lt;none&gt;</code> như bức ảnh ở trên, đến <code>layer</code> cuối cùng thì mới đầy đủ <code>image</code> của chúng ta và đặt tên chính xác. Cùng xem kích thước các <code>layers</code> tăng dần kìa.</p><figure class=\"image\"><img src=\"https://images.viblo.asia/b075da82-5b20-4317-b2a2-e9f393412c59.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/b075da82-5b20-4317-b2a2-e9f393412c59.png 2x\" sizes=\"100vw\"></figure><p>Dòng <code>---&gt; Using cache</code> xuất hiện mỗi khi bạn <code>build image</code> chính là tái sử dụng các <code>layers</code>. Những <code>layers</code> mà không được tái sử dụng nữa được gọi là <code>dangling images</code>, tạm dịch là những <code>image</code> lơ lửng -&gt; nó không trỏ tới <code>images</code> nào cả.</p><p>Ủa lạ hây, phải gọi mà <code>dangling layers</code> mới đúng chứ nhỉ ? Các tài liệu mà mình tham khảo chưa thấy có khái niệm <a href=\"https://www.google.com/search?newwindow=1&amp;ei=w1uXXLuFGIO_wAO49rfoDQ&amp;q=dangling+layers+docker&amp;oq=dangling+layers+docker&amp;gs_l=psy-ab.3..0i22i30.1838.4144..4153...2.0..0.407.1522.1j2j3j0j1......0....1..gws-wiz.fz1wnCHDa1c\">dangling layers</a>, chỉ có <a href=\"https://www.google.com/search?newwindow=1&amp;ei=yFuXXJ2CIZi5wAOx1ovADQ&amp;q=dangling+images+docker&amp;oq=dangling+images+docker&amp;gs_l=psy-ab.3..0i203l2j0i5i30l5j0i7i5i30j0i5i30j0i8i30.161652.162575..162597...1.0..2.484.1547.1j1j1j2j1......0....1..gws-wiz.......0i71j0i7i30j0i8i7i30j0i8i7i10i30.dK2m3zte-DY\">dangling images</a> thôi. Mà câu lệnh <code>docker images -a</code> cũng trả về cả danh sách <code>images</code> &amp;&amp; danh sách <code>layers</code> nữa, <code>-a</code> là viết tắt của <code>all</code>, thế <code>layers</code> với <code>images</code> là <code>sêm sêm</code> nhau à. Cũng có thể hiểu như vậy, vì nếu trong <code>Dockerfile</code>, ta xóa bỏ đi vài dòng cuối, thì <code>layers</code> ngoài cùng đó trở thành <code>images</code> còn gì&nbsp;</p><h2 style=\"margin-left:0px;\"><strong>6. Một vài lưu ý nhỏ</strong></h2><p>Có một chút lưu ý khi sử dụng Docker như sau:</p><p>Quy định <code>phiên bản</code> của image chi tiết nhất có thể.</p><p>Nếu bạn define</p><pre><code class=\"language-plaintext\">services:\n  mysql:\n    image: mysql\n    container_name: mysql\n</code></pre><p>thì mặc định, Docker sẽ pull <code>image mysql phiên bản mới nhất về</code>, ở thời điểm bạn viết <code>Dockerfile</code> thì có thể mysql phiên bản mới nhất là <code>5.7</code> nhưng đến khi người khác settup project thì có thể nó đã lên tới phiên bản <code>8.0</code></p><p>Và ở giữa phiên bản có những sự thay đổi nhất định, có thể một <code>hàm, phương thức</code> nào đó hoạt động tốt ở <code>mysql 5.7</code> nhưng không hoạt động tốt ở <code>mysql 8.0</code>, ví dụ vậy. Như thế sẽ dễ phát sinh bug tiềm ẩn và cũng vi phạm tính đồng nhất môi trường mà <code>Docker</code> lấy làm tôn chỉ.</p><p>Ở Dockerfile, các phần dễ thay đổi thì thực hiện về sau.</p><p>Như lý thuyết về phần <code>layer</code> đã nhắc tới, nếu ở một <code>layer</code> có sự thay đổi thì kể từ layer đó trở về sau, tất cả sẽ được build lại</p><p>Do vậy, những câu lệnh nào có khả năng thay đôỉ cao, bạn hãy đặt nó xuống dưới cùng.</p><p>Hãy xóa bỏ những <code>layers</code> không cần thiết</p><p>Những <code>dangling images</code> không còn hữu ích nữa, chúng cũng không được Docker tự động xóa, mà chúng ta sẽ xóa thủ công nó đi để giải phóng bộ nhớ. Cũng chưa rõ các phiên bản sau này, Docker có tự động xử lý việc này không</p><p>Hôm nay là 24/03/2019, Dương lịch, Linux OS</p><p><code>docker -v --&gt;&gt; Docker version 18.09.0, build 4d60db4</code></p><ol><li>Danh sách images:</li><li>Chỉnh sửa nội dung 1 dòng lệnh gần cuối của <code>Dockerfile</code> (giữ nguyên số lượng câu lệnh) và tiến hành <code>build image</code> thì thấy từ vị trí thay đổi trở đi không còn được sử dụng <code>cache</code> nữa</li><li>Kiểm danh sách images thì thấy số lượng <code>none images</code> tăng lên -&gt; Oh, đúng rồi ^_^</li><li>Kiểm tra danh sách image \"lơ lửng\", xóa nó đi và kiểm tra lại</li></ol><h2 style=\"margin-left:0px;\"><strong>5. Updating ...</strong></h2><ul><li>Trong phần 5 chúng ta sẽ cùng tìm hiểu về deploy with Docker nhé (bao gồm cấu hình nginx, sử dụng haproxy ....) Mời mọi người đón đọc.</li></ul>','https://news.cloud365.vn/wp-content/uploads/2019/07/docker-compose.png','2021-04-20 21:59:26','2021-04-18 00:44:45',0,11),(10,'Docker: Chưa biết gì đến biết dùng (Phần 3: Docker-compose)','','<h2 style=\"margin-left:0px;\"><strong>1. Mở đầu</strong></h2><p>Xin chào các bạn, sau khi đi qua hai phần đầu của series: <code>Docker - Chưa biết gì đến biết dùng</code>, chúng ta đã tìm hiểu <code>Docker, dockerfile, image, container ...</code> là gì và sử dụng chúng như thế nào.</p><p>Hôm nay chúng ta sẽ tiếp tục tìm hiểu <code>docker-compose</code> - một công cụ <code>kết nối</code> các <code>container</code> lại và làm cho chúng có thể <code>tương tác</code> với nhau.</p><figure class=\"image\"><img src=\"https://images.viblo.asia/4ba52c53-7c59-4443-b1fd-f47b460455a3.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/4ba52c53-7c59-4443-b1fd-f47b460455a3.png 2x\" sizes=\"100vw\"></figure><h2 style=\"margin-left:0px;\"><strong>2. Bài toán</strong></h2><p>Câu chuyện đặt ra là:</p><p><code>-&gt; Chúng ta muốn ứng dụng Docker cho</code></p><p>Dự án <code>mới</code></p><p>Hoặc dự án <code>đang phát triển</code></p><p><code>-&gt; Vậy chúng ta làm như thế nào ?</code></p><p>Qua tìm hiểu ở hai phần đầu của series, chúng ta hoàn toàn có thể sử dụng <code>Dockerfile</code></p><p>Cài đặt tất cả những môi trường cần thiết (như mysql, redis, php,... ) lên một container <code>duy nhất</code></p><p>Rồi chạy project trên container đó.</p><figure class=\"image\"><img src=\"https://images.viblo.asia/58e1a26b-1afc-48aa-b139-de5c8021f67f.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/58e1a26b-1afc-48aa-b139-de5c8021f67f.png 2x\" sizes=\"100vw\"></figure><p><code>-&gt; Tuy nhiên:</code></p><p>Nếu như bạn muốn dùng kết hợp nhiều <code>image có sẵn</code> trên <a href=\"https://hub.docker.com/\">DockerHub</a> thì sao ?</p><p>Nếu một cơ sở dữ liệu <code>dùng chung</code> cho nhiều project thì sẽ xử lý thế nào ?</p><p>Hơn nữa, với tư duy của OOP, 1 class thì không nên <code>cõng nhiều nhiệm vụ</code>.</p><p><code>-&gt; Từ đó sinh ra docker-compose để kết nối các container riêng lẻ với nhau.</code></p><ul><li>Khi đó, chúng ta sẽ xây dựng nhiều container, khi nào cần tương tác với database thì gọi tới <code>container mysql</code> chẳng hạn, tương tác với redis thì gọi tới <code>container redis</code>, cần cái gì thì gọi tới container làm nhiệm vụ đó.</li></ul><figure class=\"image\"><img src=\"https://images.viblo.asia/fd676d6c-88ef-4c1a-a148-4eb871f23401.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/fd676d6c-88ef-4c1a-a148-4eb871f23401.png 2x\" sizes=\"100vw\"></figure><ul><li>Cùng nhìn hình ảnh con <code>bạch tuộc</code> đại diện cho <code>docker-compose</code> (mình đoán thế) đang dùng các xúc tu để cuộn các container lên kìa.</li></ul><p><code>-&gt; Okie, ý tưởng cơ bản là vậy, cùng tìm hiểu chi tiết nhé !</code></p><p>À quên, bài viết sử dụng <a href=\"https://rubyonrails.org/\">Rails framework</a> (một framework của Ruby dùng để lập trình web) để ứng dụng Docker, còn với các framework của <code>PHP (Laravel, Yii, ...)</code> hay <code>Python (Django, ...)</code> thì mình sẽ tìm cách làm tương tự nha.</p><p>Quan trọng là mình hiểu cách sử dụng <code>docker-compose</code>, nếu có điều kiện, mình sẽ tìm hiểu và viết thêm bài hướng dẫn sử dụng Docker trên Laravel hoặc các framework khác.</p><p>Các bạn cũng có thể skip để chuyển sang <a href=\"https://viblo.asia/p/docker-chua-biet-gi-den-biet-dung-phan-4-mot-so-trick-toi-uu-va-luu-y-LzD5dJREZjY\">Docker: Chưa biết gì đến biết dùng ( Phần 4 - Một số trick tối ưu và lưu ý )</a></p><p><code>Let go</code></p><h2 style=\"margin-left:0px;\"><strong>3. Cài đặt Docker-compose</strong></h2><p>Tham khảo trên <a href=\"https://docs.docker.com/compose/install\">trang chủ</a> nào, trên <code>Linux</code> thì sẽ như sau:</p><ul><li><code>Step 1:</code> Run this command to download the latest version of Docker Compose.</li></ul><pre><code class=\"language-plaintext\">sudo curl -L \"https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\n</code></pre><ul><li><code>Step 2:</code> Apply executable permissions to the binary</li></ul><pre><code class=\"language-plaintext\">sudo chmod +x /usr/local/bin/docker-compose\n</code></pre><ul><li><code>Step 3:</code> Test the installation</li></ul><pre><code class=\"language-plaintext\">docker-compose --version\n</code></pre><p>-&gt; Đây là phiên bản đang cài đặt trên máy tính của mình:</p><pre><code class=\"language-plaintext\">docker-compose version 1.23.1, build b02f1306\n</code></pre><p><code>-&gt; Xong roài, có vẻ nhanh - gọn - nhẹ</code>&nbsp;</p><h2 style=\"margin-left:0px;\"><strong>4. Cấu trúc thư mục</strong></h2><p><code>-&gt; Tham khảo tài liệu từ đâu ?</code></p><p>Khá là hay ho khi trên trang chủ Docker đã có bài hướng dẫn <a href=\"https://docs.docker.com/compose/rails\">Docker for Rails</a>.</p><p>Thông thường, mình thấy tham khảo trên trang chủ cũng khá là đủ rồi</p><p>Nhưng cũng hơi bất ngờ khi trong thực tế làm dự án, anh em trong team nhận thấy vẫn còn một số điểm <code>chưa được thực sự tối ưu</code></p><p>Nên sau đây chúng ta cùng tìm hiểu cách <code>apply docker-compose</code> dựa vào bài hướng dẫn trên và đống thời <code>tối ưu</code> hơn nhé ! Nếu các bạn nhận thấy phần nào có thể làm tốt hơn thì mời comment bên dưới nha.</p><p><code>-&gt; Tạo các file cấu hình</code></p><p>Bao gồm <a href=\"https://github.com/HoanKy/docker_tutorial/tree/rails_mysql_core\">3 file sau</a>:</p><figure class=\"image\"><img src=\"https://images.viblo.asia/27e04dce-ee4f-4dbd-9eb4-819371f78e40.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/27e04dce-ee4f-4dbd-9eb4-819371f78e40.png 2x\" sizes=\"100vw\"></figure><p><code>1. docker / entrypoint.sh</code>:</p><p>Liệt kê những câu lệnh cần chạy sau khi bật container.</p><p><code>2. Dockerfile</code></p><p>Về công dụng của nó thì chắc hẳn các bạn còn nhớ chúng ta đã đề cập ở <a href=\"https://viblo.asia/p/docker-chua-biet-gi-den-biet-dung-phan-2-dockerfile-RQqKLzeOl7z#_21-dockerfile-la-gi--2\">bài trước</a>:</p><figure class=\"image\"><img src=\"https://images.viblo.asia/e5fd3528-9874-4554-867b-c5d29b073c59.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/e5fd3528-9874-4554-867b-c5d29b073c59.png 2x\" sizes=\"100vw\"></figure><p><code>3. docker-compose.yml</code>:</p><p>Dùng để <code>khai báo</code> và <code>điều phối</code> hoạt động của các <code>container</code> trong project.</p><h2 style=\"margin-left:0px;\"><strong>5. Xác định các container cần thiết</strong></h2><p>Ở mức cơ bản nhất, chúng ta sẽ xây dựng 2 container:</p><p><code>-&gt; Thứ nhất là container dùng để kết nối tới cơ sở dữ liệu.</code></p><p>Hiện nay, phần lớn các dự án có lẽ hay sử dụng <code>mysql</code>, để gần gũi và quen thuộc với mọi người nên mình sẽ dùng cơ sở dữ liệu <a href=\"https://hub.docker.com/_/mysql\">mysql</a>.</p><p>Còn nếu hịn hò hơn thì bạn có thể <a href=\"https://viblo.asia/p/8-diem-so-sanh-giua-mysql-va-postgresql-de-chon-lua-cai-nao-phu-hop-hon-OeVKB4NElkW\">tìm hiểu</a> và sử dụng <code>postgresql</code> nhé</p><p>Teachnical leader của dự án mình cũng khuyến khích sài công cụ này, và google một hồi thì có vẻ như nó có nhiều ưu điểm hơn thật, ví dụ như lưu trữ với kiểu dữ liệu array hay gán giá trị mặc định với kiểu dữ liệu <code>text</code> ...</p><p>Quay trở lại vấn đề chính nào, quan sát:</p><pre><code class=\"language-plaintext\">https://hub.docker.com/_/mysql/\n</code></pre><p>Chúng ta sẽ thấy tên organization là <code>/_/</code> và bên dưới tên image có dòng chữ <code>Docker Official Images</code></p><figure class=\"image\"><img src=\"https://images.viblo.asia/56906740-0f2c-4c95-8cff-eb8558a4e7fa.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/56906740-0f2c-4c95-8cff-eb8558a4e7fa.png 2x\" sizes=\"100vw\"></figure><p>Đây chính là những <code>image chính thức</code> được Docker cung cấp, chúng ta sẽ yên tâm hơn khi sử dụng, và khuyến cáo luôn là nên sử dụng (Hàng chính hãng, ít có khả năng gặp bug hơn hoặc chèn mã độc)</p><hr><p>Trên DockerHub còn rất nhiều image khác dành cho <a href=\"https://hub.docker.com/search?q=mysql&amp;type=image\">mysql</a>, ví dụ <a href=\"https://hub.docker.com/r/bitnami/mysql\">bitnami/mysql</a></p><figure class=\"image\"><img src=\"https://images.viblo.asia/9d71b570-8fe3-4c45-b072-00527fb7d3ac.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/9d71b570-8fe3-4c45-b072-00527fb7d3ac.png 2x\" sizes=\"100vw\"></figure><p>Đây là những image do các cá nhân, tổ chức khác xây dựng, có thể sẽ có những cải tiến so với bản official nhưng độ tin cậy và chính xác thì khó mà bằng bản chuẩn được.</p><hr><p><code>-&gt; Thứ hai là container dùng cho web application.</code></p><p>Có thể có bạn chưa rõ, ta có PHP là một ngôn ngữ lập trình, Laravel là một PHP framework, dùng để lập trình web.</p><p>Thì tương tự như vậy, Ruby cũng là một ngôn ngữ lập trình, Rails là một Ruby framework dùng để lập trình web.</p><figure class=\"image\"><img src=\"https://images.viblo.asia/8bae3636-1c7d-4ae6-bc4b-d85e1346ed0c.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/8bae3636-1c7d-4ae6-bc4b-d85e1346ed0c.png 2x\" sizes=\"100vw\"></figure><p>Lát nữa chúng ta dùng image <a href=\"https://hub.docker.com/_/ruby\">ruby</a> này để tạo <code>container</code> cho <code>web application</code> nhé !</p><hr><p><code>-&gt; Okie xong, đã xác định được 2 image tương ứng với 2 container cần xây dựng.</code></p><h2 style=\"margin-left:0px;\"><strong>6. Viết docker-compose</strong></h2><p>Chúng ta sẽ viết <code>docker-compose.yml</code> trước để có cái nhìn tổng quan về các services trong project nhé</p><ul><li>Phiên bản của <code>docker-compose</code></li></ul><pre><code class=\"language-plaintext\">version: \'3.5\'\n</code></pre><ul><li>Liệt kê các services</li></ul><pre><code class=\"language-plaintext\">services:\n    mysql:\n        ...\n        ...\n        ...\n    app:\n        ...\n        ...\n        ...\n</code></pre><ul><li>Cài đặt cho từng services</li></ul><pre><code class=\"language-plaintext\">mysql:\n    image: mysql:5.7\n    container_name: mysql\n    restart: always\n    environment:\n      MYSQL_ROOT_PASSWORD: root\n    volumes:\n      - docker/database:/var/lib/mysql\n</code></pre><p>☑ <a href=\"https://docs.docker.com/compose/compose-file/#image\">image</a>: Chỉ định <code>image</code> để khởi động <code>container</code>, ở đây ta dùng image có sẵn như đã nói ở mục 4.</p><p>☑ <a href=\"https://docs.docker.com/compose/compose-file/#container_name\">container_name</a>: Chỉ định tên container tùy chỉnh, thay vì tên mặc định.</p><p>☑ <a href=\"https://docs.docker.com/compose/compose-file/#restart\">restart</a>: Giá trị mặc định là <code>no</code>, còn nếu bạn đặt là <code>always</code> thì container sẽ khởi động lại nếu mã thoát cho biết lỗi không thành công.</p><p>☑ <a href=\"https://docs.docker.com/compose/compose-file/#environment\">environment</a>: Thêm các biến môi trường</p><p>☑ <a href=\"https://docs.docker.com/compose/compose-file/#volumes\">volumes</a>: Chia sẻ dữ liệu giữa container (máy ảo) và host (máy thật) hoặc giữa các container với nhau.</p><p>Ví dụ:</p><ul><li>Khi <code>container mysql</code> tạo và lưu dữ liệu thì dữ liệu này sẽ lưu ở trong thư mục <code>var/lib/mysql</code> của container. Như vậy nếu như container này bị xóa đi thì chúng ta sẽ <code>mất toàn bộ data</code></li></ul><figure class=\"image\"><img src=\"https://images.viblo.asia/eceab69d-3056-458e-a2ec-dc067b61def9.gif\" alt=\"\" srcset=\"https://images.viblo.asia/retina/eceab69d-3056-458e-a2ec-dc067b61def9.gif 2x\" sizes=\"100vw\"></figure><p>Ôi buồn quá -_- Làm gì bây giờ ?</p><p>Giải pháp là chúng ta sẽ <code>sao lưu</code> dữ liệu đó ra ngoài máy host, như vậy khi container bị xóa, dữ liệu sẽ vẫn được lưu trữ ở máy host. Và ở khi bật lại container, dữ liệu lại được mount từ máy host vào trong container và chúng ta tiếp tục sử dụng nó bình thường.</p><p>Thư mục lưu trữ data ở ngoài máy host sẽ không được <code>commit</code> vào git, ta đưa nó vào <a href=\"https://github.com/HoanKy/docker_tutorial/blob/rails_mysql/.gitignore#L29\">gitignore</a>.</p><pre><code class=\"language-plaintext\"># Ignore data backup\ndocker/database\n</code></pre><p>Ở một số hướng dẫn có lưu dữ liệu backup vào trong thư mục mà framework đã <code>gitignore</code> sẵn, ví dụ như đối với <code>Rails</code> là <code>/tmp</code> hoặc lưu ở ngoài thư mục dự án thì không cần <code>gitignore</code> nó nữa.</p><pre><code class=\"language-plaintext\">app:\n    container_name: app\n    build: .\n    volumes:\n      - .:/my_app\n    ports:\n      - \"3000:3000\"\n    environment:\n      DATABASE_HOST: mysql\n      DATABASE_USER_NAME: root\n      DATABASE_PASSWORD: root\n</code></pre><p>☑ <a href=\"https://docs.docker.com/compose/compose-file/#build\">build</a>: Sử dụng khi chúng ta không xây dựng <code>container</code> từ <code>image</code> có sẵn nữa mà xây dựng nó từ <code>Dockerfile</code>.</p><ul><li>Nếu <code>Dockerfile</code> nằm cùng thư mục với <code>docker-compose.yml</code> thì chỉ cần</li></ul><pre><code class=\"language-plaintext\">build: .\n</code></pre><ul><li>Nếu bạn muốn đặt <code>Dockerfile</code> trong thư mục <code>docker</code> để cùng với <code>entrypoint.sh</code> cho gọn thì sửa thành</li></ul><pre><code class=\"language-plaintext\">    build:\n       context: ./\n       dockerfile: docker/Dockerfile\n</code></pre><p>☑ <a href=\"https://docs.docker.com/compose/compose-file/#ports\">ports</a>: Cấu hình cổng kết nối</p><p>Có thể chỉ định cả 2 cổng (HOST:CONTAINER) tức là (cổng ở máy thật: cổng ở máy ảo) hoặc chỉ định mình cổng cho máy ảo thôi.</p><p>Ví dụ: <code>\"2222:3333\"</code> Khi bạn truy cập vào cổng <code>2222</code> ở máy thật thì sẽ được trỏ tới truy cập ở cổng <code>3333</code> của máy ảo.</p><p>☑ <a href=\"https://docs.docker.com/compose/compose-file/#environment\">environment</a>: Bổ sung các biến môi trường.</p><p>Lưu ý rằng <code>DATABASE_HOST</code> chính là tên của service mysql.</p><p>Mình đã push code lên <a href=\"https://github.com/HoanKy/docker_tutorial/blob/rails_mysql_core/docker-compose.yml\">Github</a>.</p><h2 style=\"margin-left:0px;\"><strong>7. Viết Dockerfile</strong></h2><p>-&gt; Bây giờ ta sẽ viết <code>Dockerfile</code> cho container <code>app</code> trên kia nhé, chỗ mà <code>build .</code> ấy.</p><p>Image cơ sở</p><pre><code class=\"language-plaintext\">FROM ruby:2.5.1\n</code></pre><p>Đánh dấu lãnh thổ chút</p><pre><code class=\"language-plaintext\">LABEL author.name=\"HoanKy\" \\\nauthor.email=\"hoanki2212@gmail.com\"\n</code></pre><p>Cặt đặt các phần mềm cần thiết cho máy ảo</p><pre><code class=\"language-plaintext\">RUN apt-get update &amp;&amp; \\\n  apt-get install -y nodejs nano vim\n</code></pre><p>Set timezone cho máy ảo (Optional)</p><pre><code class=\"language-plaintext\">ENV TZ=Asia/Ho_Chi_Minh\nRUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone\n</code></pre><p>Chỉ định thư mục làm việc mặc định (Optional)</p><pre><code class=\"language-plaintext\">ENV APP_PATH /my_app\nWORKDIR $APP_PATH\n</code></pre><p>Cài đặt framework cần thiết cho dự án</p><pre><code class=\"language-plaintext\">COPY Gemfile Gemfile.lock $APP_PATH/\nRUN bundle install --without production --retry 2 \\\n  --jobs `expr $(cat /proc/cpuinfo | grep -c \"cpu cores\") - 1`\n</code></pre><p>Copy tất cả dữ liệu tự máy host vào trong container</p><pre><code class=\"language-plaintext\">COPY . $APP_PATH\n</code></pre><p>Cấu hình file <code>entrypoint.sh</code></p><pre><code class=\"language-plaintext\">COPY docker/entrypoint.sh /usr/bin/\nRUN chmod +x /usr/bin/entrypoint.sh\nENTRYPOINT [\"entrypoint.sh\"]\nEXPOSE 3000\n</code></pre><p>Thiết lập câu lệnh mặc định sẽ chạy khi khởi động <code>container</code></p><pre><code class=\"language-plaintext\">CMD [\"rails\", \"server\", \"-b\", \"0.0.0.0\"]\n</code></pre><p>-&gt; Mình có push code mẫu lên <a href=\"https://github.com/HoanKy/docker_tutorial/blob/rails_mysql_core/Dockerfile\">Github</a></p><h2 style=\"margin-left:0px;\"><strong>8. Viết </strong><a href=\"http://entrypoint.sh/\"><strong>entrypoint.sh</strong></a></h2><p>-&gt; Chạy <code>file sh</code> với bash chứ ko phải là <a href=\"https://viblo.asia/p/hieu-ro-hon-toi-uu-va-su-dung-phim-tat-cho-terminal-ORNZqowM50n\">sh hay zsh</a></p><pre><code class=\"language-plaintext\">#!/bin/bash\nset -e\n</code></pre><p>-&gt; Xóa tiến trình cũ</p><pre><code class=\"language-plaintext\">rm -f /my_app/tmp/pids/server.pid\n</code></pre><p>Mỗi khi khởi chạy <code>rails server</code> sẽ có một mã <code>id</code> được sinh ra và lưu vào file <code>tmp/pids/server.pid</code> để đánh dấu rằng đã tồn tại tiến trình rails đang chạy.</p><p>Khi bạn stop <code>rails server</code> thì rails sẽ xóa nội dung file này, tuy nhiên trong trường hợp bạn <code>kill rails process</code> thì rails server sẽ bị stop mà chưa kịp xóa nội dung file, và khi bạn start lại server thì sẽ gặp lỗi</p><pre><code class=\"language-plaintext\">=&gt; Booting Puma\n=&gt; Rails 5.0.0 application starting in development on http://0.0.0.0:3000\n=&gt; Run `rails server -h` for more startup options\nA server is already running. Check /balabala/tmp/pids/server.pid.\nExiting\n</code></pre><p>Như vậy, ta sẽ xóa thủ công nó luôn để đảm bảo không gặp lỗi này, gọi là chặn từ lúc trứng nước.</p><p>-&gt; Thực thi câu lệnh truyền vào.</p><pre><code class=\"language-plaintext\">exec \"$@\"\n</code></pre><p>Mình có push code mẫu lên <a href=\"https://github.com/HoanKy/docker_tutorial/blob/rails_mysql_core/docker/entrypoint.sh\">Github</a></p><h2 style=\"margin-left:0px;\"><strong>9. Sử dụng docker-compose</strong></h2><h3 style=\"margin-left:0px;\"><strong>9.1 Trường hợp tạo dự án mới</strong></h3><p><code>-&gt; Khi setup project với Rails trực tiếp trên máy thật theo cách truyền thống</code></p><ul><li>Chạy câu lệnh sau để initialize project, khi đó các file, folder sẽ tự động được sinh ra:</li></ul><pre><code class=\"language-plaintext\">rails new . --force --no-deps --database=mysql\n</code></pre><p><code>-&gt; Khi setup project thông qua Docker thì sao ?</code></p><p>Khi đó, chúng ta sẽ không cài Rails vào máy thật nữa.</p><p>Hãy run một <code>container</code> đã cài <code>Rails</code> lên và chạy câu lệnh trên bên trong <code>container</code> đó, rồi mount các file, folder của framework được vừa được tạo ra ngoài máy host.</p><p>Ở đây, container đó chính là container <code>app</code> mà ta vừa xây dựng ở trên.</p><p>Cú pháp để chạy một câu lệnh bên trong <code>container</code> như sau:</p><pre><code class=\"language-plaintext\">sudo docker-compose run + tên container + Câu lệnh muốn chạy\n</code></pre><p>Như vậy, bạn hãy chạy:</p><pre><code class=\"language-plaintext\">docker-compose run app rails new . --force --no-deps --database=mysql\n</code></pre><figure class=\"image\"><img src=\"https://images.viblo.asia/9adbd67c-01ff-4f59-a905-d1e6e191ff12.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/9adbd67c-01ff-4f59-a905-d1e6e191ff12.png 2x\" sizes=\"100vw\"></figure><ul><li>Việc này sẽ mấy chút thời gian, trong quá trình chờ đợi thì bạn nên theo dõi log ở Terminal để xem các bước Docker thực hiện như thế nào nhé !</li></ul><p><code>-&gt; Note 1: Khai báo Rails version</code></p><p>Nếu bạn cài Rails trực tiếp trên máy thật thì đã có sẵn phiên bản của Ruby (ngôn ngữ lập trình) và Rails (framework của ngôn ngữ) rồi, ví dụ:</p><pre><code class=\"language-plaintext\"> $ ruby -v \n ruby 2.5.1p57 (2018-03-29 revision 63029) [x86_64-linux]\n\n $ rails -v\n Rails 5.2.2.1\n</code></pre><p>Còn như ở Dockerfile phía trên, chúng ta mới chỉ có</p><pre><code class=\"language-plaintext\">FROM ruby:2.5.1\n</code></pre><p>chứ chưa cài đặt Rails.</p><p>Thứ hai là khi build image, ở step</p><pre><code class=\"language-plaintext\">COPY Gemfile Gemfile.lock $APP_PATH/\n</code></pre><p>có nghĩa là copy Gemfile từ máy host vào container thì chúng ta chưa có file này ở máy host:</p><p>Như thế sẽ gặp lỗi: <code>no such file or directory</code></p><p>Vậy nên, chúng ta tạo thêm 2 file: Gemfile và Gemfile.lock</p><p>Gemfile:</p><pre><code class=\"language-plaintext\">source \"https://rubygems.org\"\ngem \"rails\", \"~&gt;5\"\n</code></pre><p>Gemfile.lock</p><pre><code class=\"language-plaintext\"># File này để trống\n</code></pre><figure class=\"image\"><img src=\"https://images.viblo.asia/ae9229e5-9d76-44cb-b512-5525f49ec0d8.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/ae9229e5-9d76-44cb-b512-5525f49ec0d8.png 2x\" sizes=\"100vw\"></figure><p>Rồi sau đó hẵng chạy lại câu lệnh</p><pre><code class=\"language-plaintext\">docker-compose run app rails new . --force --no-deps --database=mysql\n</code></pre><p>Mình đã push code mẫu lên <a href=\"https://github.com/HoanKy/docker_tutorial/tree/rails_mysql_core\">Github</a> rồi nhé, bởi vì đây là config thư viện của Rails nên không giới thiệu chung với các config của Docker.</p><p><code>-&gt; Note 2: Cấp lại quyền cho file, folder</code></p><ul><li>Có thể bạn đã biết, mặc định thì docker chạy với <code>user root</code> nên những file, folder nó tạo ra (sau khi <code>mount</code> từ <code>container</code> ra máy <code>host</code>) cũng ở quyền <code>root</code>.</li></ul><figure class=\"image\"><img src=\"https://images.viblo.asia/ae97cd2c-6be0-48b6-8703-8c93830c4c99.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/ae97cd2c-6be0-48b6-8703-8c93830c4c99.png 2x\" sizes=\"100vw\"></figure><p>Vậy nên khi bạn dùng editor để <code>chỉnh sửa</code> những file này thì <code>Linux OS</code> sẽ thông báo.</p><pre><code class=\"language-plaintext\">Permission denied\n</code></pre><p>Giải pháp thì set lại quyền cho nó thôi</p><pre><code class=\"language-plaintext\">sudo chown -R $USER:$USER .\n</code></pre><figure class=\"image\"><img src=\"https://images.viblo.asia/e3b58304-4ede-4ade-8e86-20ea482b4b05.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/e3b58304-4ede-4ade-8e86-20ea482b4b05.png 2x\" sizes=\"100vw\"></figure><p><code>-&gt; Note 3: Cấu hình để kết nối tới database</code></p><ul><li>Đối với <code>Rails framework</code> thì config này nằm ở file <code>config/database.yml</code></li></ul><p>Sửa từ</p><pre><code class=\"language-plaintext\">default: &amp;default\n    adapter: mysql2\n    encoding: utf8\n    pool: &lt;%= ENV.fetch(\"RAILS_MAX_THREADS\") { 5 } %&gt;\n    username: root\n    password:\n    host: localhost\n</code></pre><p>thành</p><pre><code class=\"language-plaintext\">default: &amp;default\n      adapter: mysql2\n      encoding: utf8\n      pool: &lt;%= ENV.fetch(\"RAILS_MAX_THREADS\") { 5 } %&gt;\n      username: &lt;%= ENV.fetch(\"DATABASE_USER_NAME\") || \"root\" %&gt;\n      password: &lt;%= ENV.fetch(\"DATABASE_PASSWORD\") || \"root\" %&gt;\n      host: &lt;%= ENV.fetch(\"DATABASE_HOST\") || \"mysql\" %&gt;\n</code></pre><ul><li>Xong xuôi thì bạn chuyển qua mục 10.2 được rồi.</li></ul><h3 style=\"margin-left:0px;\"><strong>9.2 Trường hợp cho dự án đang phát triển</strong></h3><p><code>-&gt; Sửa cấu hình kết nối database</code></p><ul><li>Chỉnh sửa file <code>config setting connect database</code> cho phù hợp nếu cần (ví dụ với Rails: config/database.yml )</li></ul><p><code>-&gt; Build các image cần thiết</code></p><p>Cú pháp</p><pre><code class=\"language-plaintext\">docker-compose build\n</code></pre><p>Nếu gặp lỗi này</p><pre><code class=\"language-plaintext\">IOError: Can not read file in context: /home/nguyenvanhoan/GitRepo/docker_tutorial/docker/database/ca-key.pem\n</code></pre><p>Do một số file trong thư mục <code>back_up database</code> cần quyền <code>root</code> để truy cập, hãy đổi thành</p><pre><code class=\"language-plaintext\">sudo docker-compose build\n</code></pre><figure class=\"image\"><img src=\"https://images.viblo.asia/59fb3fcd-980d-43a5-a8b2-59d0ac3a6900.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/59fb3fcd-980d-43a5-a8b2-59d0ac3a6900.png 2x\" sizes=\"100vw\"></figure><p><code>-&gt; Khởi chạy container:</code></p><p>Cú pháp</p><pre><code class=\"language-plaintext\">sudo docker-compose up\n</code></pre><p>Màn hình log:</p><figure class=\"image\"><img src=\"https://images.viblo.asia/ac2ec4d8-fb52-4df6-a98d-7c4ca5223eff.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/ac2ec4d8-fb52-4df6-a98d-7c4ca5223eff.png 2x\" sizes=\"100vw\"></figure><p>Òa, log bắn ra ầm ầm, kệ nó đi, bạn vào địa chỉ :</p><pre><code class=\"language-plaintext\"> http://localhost:3000\n</code></pre><p>và tận hưởng thành quả nào:</p><figure class=\"image\"><img src=\"https://images.viblo.asia/eb546c30-f0e7-468f-b915-f708f6531f50.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/eb546c30-f0e7-468f-b915-f708f6531f50.png 2x\" sizes=\"100vw\"></figure><p><code>-&gt; Vâng, bug đỏ lòm đập vào mặt, lỗi này là do chúng ta chưa tạo database.</code></p><p>Tạo cơ sở dữ liệu</p><p>Với mỗi framework sẽ có cách khác nhau để tạo <code>database</code>.</p><p>Còn đối với rails, nếu ở máy thật, bạn cần gõ 2 câu lệnh sau để tạo database:</p><pre><code class=\"language-plaintext\"># Xóa và tạo lại các bảng và quan hệ giữa chúng\nrails db:migrate:reset\n</code></pre><p>Còn bây giờ, chúng ta hãy truy cập vào máy ảo để chạy câu lệnh này, bằng cách</p><pre><code class=\"language-plaintext\">sudo docker-compose run + tên container + Câu lệnh muốn chạy\n</code></pre><p>Và ở đây, ta cần:</p><pre><code class=\"language-plaintext\">sudo docker-compose run app rails db:migrate:reset\n</code></pre><figure class=\"image\"><img src=\"https://images.viblo.asia/54742a62-9504-4307-af65-1646a1272a47.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/54742a62-9504-4307-af65-1646a1272a47.png 2x\" sizes=\"100vw\"></figure><p>Truy cập vào <code>http://localhost:3000</code> nào</p><figure class=\"image\"><img src=\"https://images.viblo.asia/e8afba11-056a-4e47-b708-cee0137d0bdf.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/e8afba11-056a-4e47-b708-cee0137d0bdf.png 2x\" sizes=\"100vw\"></figure><p>Lưu ý</p><ul><li>Nếu vừa rồi bạn ấn <code>Ctrl + C</code> để dừng <code>docker-compose up</code> thì khi chạy câu lệnh tạo cơ sở dữ liệu sẽ gặp lỗi</li></ul><p>Vì sao ?</p><p>Nhìn vào log trên ta sẽ thấy</p><figure class=\"image\"><img src=\"https://images.viblo.asia/248ddd94-92e2-48df-af9d-e5863d4d7b14.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/248ddd94-92e2-48df-af9d-e5863d4d7b14.png 2x\" sizes=\"100vw\"></figure><p>Tức là <code>service mysql</code> đã bị dừng lại, vậy nên <code>service app</code> của chúng ta không thể kết nối tới <code>mysql service</code>.</p><ul><li>Để giải quyết điều này thì có nhiều cách:</li></ul><p>Đơn giản nhất là bạn giữ nguyên tab đang chạy <code>docker-compose up</code> và mở thêm tab để chạy migrate data.</p><p>Dùng option <code>-d</code></p><pre><code class=\"language-plaintext\">docker-compose up -d\n</code></pre><p>Thay đổi cách khởi động các <code>container</code> thủ công</p><p>Bài cũng đã dài, chúng ta sẽ tìm hiểu cách 3 ở phần 4 nhé, đây cũng là cách khuyến khích sử dụng.</p><p>Thay đổi cách khởi động các <code>container</code> bằng <code>depends_on</code></p><p>Cách này không khuyến khích (Cũng sẽ giải thích ở phần 4 luôn)</p><hr><ul><li>Cũng đủ kiến thức cơ bản về <code>docker-compose</code> rồi</li><li>Nếu bạn gặp lỗi hoặc bị vướng ở đoạn nào chưa hiểu thì hãy để lại bình luận bên dưới, mình sẽ support nếu có thể nhé !</li><li>Code mẫu cho phần core config mình đã push lên <a href=\"https://github.com/HoanKy/docker_tutorial/tree/rails_mysql_core\">đây</a>.</li><li>Còn code sau khi các file được sinh ra thì mình đã push lên <a href=\"https://github.com/HoanKy/docker_tutorial/tree/rails_mysql\">đây</a>.</li></ul><h2 style=\"margin-left:0px;\"><strong>10. Updating ...</strong></h2><p>Còn một chút lưu ý cũng như một số mẹo để sử dụng docker nhanh, gọn nhẹ hơn.</p><p>=&gt; Mình sẽ cập nhật ở phần 4 nhé. Mời cả nhà đón đọc !</p>','https://news.cloud365.vn/wp-content/uploads/2019/07/docker-compose.png','2021-04-20 21:57:50','2021-04-18 01:36:27',0,11),(11,'Docker: Chưa biết gì đến biết dùng (Phần 2 - Dockerfile)','','<h2 style=\"margin-left:0px;\"><strong>1. Mở đầu</strong></h2><p>Xin chào các bạn, sau khi viết xong <a href=\"https://viblo.asia/p/docker-chua-biet-gi-den-biet-dung-phan-1-ByEZkWrEZQ0\">Docker: Chưa biết gì đến biết dùng (Phần 1),</a> mình đã giới thiệu với các bạn các công nghệ ảo hóa <code>containerlization</code> với công cụ <code>docker</code> của công ty <code>Docker</code> trên hệ điều hành <code>Ubuntu</code>, nhưng mới chỉ dừng lại ở tìm hiểu lịch sử &amp;&amp; cơ chế hoạt động của Docker.</p><figure class=\"image\"><img src=\"https://images.viblo.asia/598c2e38-1a22-4ca5-9b71-154756f8739b.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/598c2e38-1a22-4ca5-9b71-154756f8739b.png 2x\" sizes=\"100vw\"></figure><p>Đây là một công cụ khá <code>hữu ích</code>, khuyên các bạn nên <code>tìm hiểu</code> và sử dụng. Trước khi đọc phần 2 này, hãy đọc phần 1 - chủ yếu về <code>lý thuyết</code>, để mình hiểu <code>bản chất</code> của Docker đã.</p><p>Hôm nay chúng ta sẽ đi <code>chi tiết</code> hơn, xem thực tế chúng ta sử dụng <code>Docker</code> như thế nào, đầu tiên sẽ là <code>Dockerfile</code> nhé ! Let go</p><h2 style=\"margin-left:0px;\"><strong>2. Dockerfile</strong></h2><h2 style=\"margin-left:0px;\"><strong>2.1 Dockerfile là gì ?</strong></h2><p>Thì đơn giản, Dockerfile là một <code>file</code></p><p>dạng text, không có đuôi, giúp thiết lập <code>cấu trúc</code> cho <code>docker image</code> nhờ chứa một tập hợp các <code>câu lệnh</code>.</p><p>Từ những câu lệnh đó, Docker có thể thực hiện <code>đóng gói</code> một docker images theo yêu cầu tùy biến của riêng bạn.</p><figure class=\"image\"><img src=\"https://images.viblo.asia/751d7512-c9e7-44a5-be56-6b1ff9096adf.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/751d7512-c9e7-44a5-be56-6b1ff9096adf.png 2x\" sizes=\"100vw\"></figure><p>=&gt; Như vậy Dockerfile sẽ <code>quy định</code> Docker image được khởi tạo <code>từ đâu</code>, gồm <code>những gì</code> trong đó.</p><h2 style=\"margin-left:0px;\"><strong>2.2 Cách viết Dockerfile</strong></h2><p>Demo như sau:</p><figure class=\"image\"><img src=\"https://images.viblo.asia/53ba5120-21d9-470e-992e-fbcd611b24d2.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/53ba5120-21d9-470e-992e-fbcd611b24d2.png 2x\" sizes=\"100vw\"></figure><p>Đầu tiên chúng ta sẽ viết <code>Dockerfile</code> để tạo nên <code>image</code> rồi tạo nên <code>container</code>, sau khi tạo được <code>container</code> rồi thì đồng nghĩa là đã tạo ra được <code>máy ảo</code> để bạn có thể khởi chạy <code>ứng dụng</code> của bạn trên máy ảo đó.</p><p>Thư mục <code>webroot</code> chứa mã nguồn chương trình, có thể là một <code>c++ app</code>, <code>java app</code> hoặc <code>web app</code> được viết bằng php hoặc ruby,.... (Ở đây, để cho đơn giản, chúng ta chỉ đặt file <code>hello.html</code>, chạy trên trình duyệt sẽ hiển thị dòng Hello Word)</p><p>Sau này, bạn dùng <code>editor</code> để lập trình trên máy thật, chỉnh sửa <code>mã nguồn</code> trong thư mục này, mọi sự thay đổi được cập nhật <code>ngay lập tức</code> trên máy ảo.</p><p>File <code>start.sh</code> chứa những câu lệnh được chạy khi bật container (có thể dùng để start mysql, nginx, redis ...)</p><p>Nào, bắt đầu viết <code>Dockerfile</code> nhé:</p><h3 style=\"margin-left:0px;\"><strong>2.2.1 Thiết lập image gốc</strong></h3><p>Đầu tiên, ta cần khai báo <code>thằng cha</code> của image này là <code>thằng nào</code>, tức là nó <code>khởi nguồn</code> từ đâu, sử dụng:</p><ul><li><strong>FROM</strong></li></ul><p><code>Image gốc</code> có thể là centos:7, ubuntu:16.04, vân vân và mây mây.</p><p>Vi dụ:</p><pre><code class=\"language-plaintext\">FROM ubuntu:16.04\n</code></pre><p>Có thể bạn sắp biết, <a href=\"https://hub.docker.com/\">Docker hub</a> - nơi lưu trữ và chia sẻ các image sẽ chứa những <code>image gốc</code> mà từ đó, bạn có thể <code>phát triển</code>, <code>cài cắm</code>, <code>thay tháo</code>, <code>chỉnh sửa</code>, <code>thêm bớt</code> để tạo ra những <code>images tùy biến</code> cho riêng bạn.</p><p>Khi Docker đọc tới câu lệnh này, nó sẽ tự động tìm xem image ubuntu:16.04 này đã tồn tại trong máy chưa, nếu chưa thì Docker sẽ tự động pull image này về. Trong đó ubuntu là tên của image, 16:04 là tag, bạn cũng có thể hiểu nó nôm na như là branch trong git.</p><figure class=\"image\"><img src=\"https://images.viblo.asia/9194ac19-5ba8-40a6-8f18-ef78f88824b4.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/9194ac19-5ba8-40a6-8f18-ef78f88824b4.png 2x\" sizes=\"100vw\"></figure><ul><li><strong>MAINTAINER</strong> : Một optional dùng để đặt tên cho tác giả của Dockerfile mà bạn đang viết. Ví dụ:</li></ul><pre><code class=\"language-plaintext\">MAINTAINER HoanKi&lt;hoanki2212@gmail.com&gt;\n</code></pre><h3 style=\"margin-left:0px;\"><strong>2.2.2 Cài đặt ứng dụng</strong></h3><p>Bây giờ, chúng ta sẽ <code>cài thêm</code> các ứng dụng, <code>thiết lập</code> môi trường cần thiết trên <code>ubuntu:16.04</code> này</p><p>Bạn có thể cài nginx, php, python, ruby, java ... phụ thuộc vào <code>nhu cầu</code> của bạn, sử dụng:</p><p><strong>RUN</strong> : Để thực thi một câu lệnh nào đó trong <code>quá trình build images</code>.</p><p><strong>CMD</strong> : Để thực thi một câu lệnh trong quá trình <code>bật container</code>.</p><p>Mỗi Dockerfile <code>chỉ có</code> một câu lệnh CMD, nếu như có <code>nhiều hơn</code> một câu lệnh CMD thì chỉ có câu lệnh CMD <code>cuối cùng</code> được sử dụng.</p><p>Một <code>câu hỏi</code> đặt ra là nếu tôi muốn khởi động <code>nhiều ứng dụng</code> khi start container thì sao, lúc đó hay nghĩ tới <code>ENTRYPOINT</code></p><p><strong>ENTRYPOINT</strong>: Để thực thi <code>một số câu lệnh</code> trong quá trình <code>start container</code>, những câu lệnh này sẽ được viết trong <code>file .sh</code>.</p><p>Ví dụ:</p><pre><code class=\"language-plaintext\"># Update ubuntu\nRUN apt-get update\n\n# Install nginx\nRUN apt-get install -y nginx\n\n# Install mysql server\nRUN echo \"mysql-server mysql-server/root_password password root\" | debconf-set-selections \\\n    &amp;&amp; echo \"mysql-server mysql-server/root_password_again password root\" | debconf-set-selections \\\n    &amp;&amp; apt-get install -y mysql-server\n</code></pre><p>Trong khi cài nginx, sẽ có câu hỏi xuất hiện và bạn cần trả lời yes/no, khi đó tùy chọn <code>-y</code> trong <code>RUN apt-get install -y nginx</code> sẽ thể hiện cho sự lựa chọn <code>yes</code> của bạn.</p><h3 style=\"margin-left:0px;\"><strong>2.2.3 Cấu hình</strong></h3><p><strong>EXPOSE</strong>: Container sẽ lắng nghe trên các cổng mạng được chỉ định khi chạy</p><p><strong>ADD</strong> : Copy file, thư mục, remote file thêm chúng vào filesystem của image.</p><p><strong>COPY</strong> : Copy file, thư mục từ host machine vào image. Có thể sử dụng url cho tập tin cần copy.</p><p><strong>WORKDIR</strong> : Định nghĩa directory cho <strong>CMD</strong></p><p><strong>VOLUME</strong> : Mount thư mục từ máy host vào container.</p><p>Tạo file .sh</p><p>Như ở phần entrypoint đã nói, cho dù chỉ cần một câu lệnh mình vẫn dùng ENTRYPOINT, để sau này dễ dàng tùy biến, phát triển.</p><p>Tạo file <a href=\"http://start.sh/\">start.sh</a> như sau</p><pre><code class=\"language-plaintext\">#!/bin/bash\nservice nginx start\nexec $@\n</code></pre><p>Ta có ví dụ ở phần này như sau:</p><pre><code class=\"language-plaintext\">ADD start.sh /venv\n\nWORKDIR /venv\n\nRUN chmod a+x /venv/*\n\nENTRYPOINT [\"/venv/start.sh\"]\n\nEXPOSE 80\n</code></pre><p>Tổng hợp lại, ta có một ví dụ cho Dockerfile như sau :</p><pre><code class=\"language-plaintext\">FROM ubuntu:16.04\n\nMAINTAINER HoanKi&lt;hoanki2212@gmail.com&gt;\n\nRUN DEBIAN_FRONTEND=noninteractive\n\nRUN apt-get update\n\nRUN apt-get install -y nginx\n\nRUN echo \"mysql-server mysql-server/root_password password root\" | debconf-set-selections \\\n    &amp;&amp; echo \"mysql-server mysql-server/root_password_again password root\" | debconf-set-selections \\\n    &amp;&amp; apt-get install -y mysql-server\n\nWORKDIR /venv\n\nCOPY start.sh /venv\n\nRUN chmod a+x /venv/*\n\nENTRYPOINT [\"/venv/start.sh\"]\n\nEXPOSE 80\n</code></pre><ul><li>Tạo file <code>hello.html</code> trong thư mục webroot:</li></ul><pre><code class=\"language-plaintext\">&lt;h1&gt;Hello word&lt;/h1&gt;\n</code></pre><p>Mình có push code mẫu lên GitHub: <a href=\"https://github.com/HoanKy/docker_tutorial/tree/dockerfile\">HoanKy/docker_tutorial</a></p><p>Còn đây là full document về <a href=\"https://docs.docker.com/engine/reference/builder\">Dockerfile</a></p><h2 style=\"margin-left:0px;\"><strong>2.3 Cách sử dụng Dockerfile</strong></h2><h3 style=\"margin-left:0px;\"><strong>2.3.1 Build docker image từ Dockerfile</strong></h3><p>Ta sử dụng câu lệnh sau:</p><blockquote><p>sudo docker build -t &lt;image_name&gt; .</p></blockquote><p>Ví dụ:</p><pre><code class=\"language-plaintext\">sudo docker build -t ubuntu-nginx . \n</code></pre><p>Bạn có thể dùng lệnh</p><pre><code class=\"language-plaintext\">docker images\n</code></pre><p>để xem thành quả nhé !</p><figure class=\"image\"><img src=\"https://images.viblo.asia/18a067f6-8bf0-48e6-a91a-e0226b18c570.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/18a067f6-8bf0-48e6-a91a-e0226b18c570.png 2x\" sizes=\"100vw\"></figure><h3 style=\"margin-left:0px;\"><strong>2.3.2 Tạo container từ image.</strong></h3><ul><li>Gõ lệnh theo syntax:</li></ul><blockquote><p>sudo docker run -v &lt;forder_in_computer&gt;:&lt;forder_in_container&gt; -p &lt;port_in_computer&gt;:&lt;port_in_container&gt; -it &lt;image_name&gt; /bin/bash</p></blockquote><p>Trong đó:</p><p>-v : Thể hiện việc mount volume, dữ liệu từ thư mục từ máy thật có thể được truy cập từ thư mục của máy ảo.</p><p>-p: Cổng mạng từ máy thật để dẫn tới cổng mạng của máy ảo đang chạy.</p><p>-t: Chạy container và mở terminal bằng /bin/bash</p><p>Ví dụ vào localhost mặc định của nginx:</p><pre><code class=\"language-plaintext\">sudo docker run -p 9000:80 -it ubuntu-nginx /bin/bash\n</code></pre><p>Kiểm tra log trên Terminal:</p><figure class=\"image\"><img src=\"https://images.viblo.asia/8708c3a7-45ed-4218-b8b5-e0586a869f9d.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/8708c3a7-45ed-4218-b8b5-e0586a869f9d.png 2x\" sizes=\"100vw\"></figure><p>Trên trình duyệt:</p><figure class=\"image\"><img src=\"https://images.viblo.asia/8351c336-9101-4344-b626-97193fd48ec8.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/8351c336-9101-4344-b626-97193fd48ec8.png 2x\" sizes=\"100vw\"></figure><ul><li>Ví dụ vào thư mục dự án ở máy thật:</li></ul><pre><code class=\"language-plaintext\">sudo docker run -v  /media/hoanki/PROJECT4/GitRepo/docker_tutorial/webroot:/var/www/html -p 9000:80 -it ubuntu-nginx /bin/bash\n</code></pre><p>Thay thế <code>/media/hoanki/PROJECT4/GitRepo/docker_tutorial/webroot</code> cho đúng với trên máy bạn nhé !</p><p>Kết quả:</p><figure class=\"image\"><img src=\"https://images.viblo.asia/08d58efe-8d45-4c5f-aa87-a59b7e96ff80.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/08d58efe-8d45-4c5f-aa87-a59b7e96ff80.png 2x\" sizes=\"100vw\"></figure><h2 style=\"margin-left:0px;\"><strong>3. Docker Hub</strong></h2><p>Docker-hub: Nơi lưu trữ và chia sẻ các image của Docker, nhưng không chỉ có vậy.</p><p>Nãy giờ bạn và tôi đang build image hoàn toàn dưới local, nhưng Docker Hub còn hỗ trợ chúng ta làm việc này trên server nữa.</p><ul><li>Mình tạo mới repo <a href=\"https://github.com/oNguyenVanHoan/docker_basic\">docker-basic</a> trên Github, như này:</li></ul><figure class=\"image\"><img src=\"https://images.viblo.asia/8aa11939-739e-440b-a1bc-eb281542ffaa.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/8aa11939-739e-440b-a1bc-eb281542ffaa.png 2x\" sizes=\"100vw\"></figure><ul><li>Sau đó mình tạo mới một repo trên <a href=\"https://hub.docker.com/\">Dockerhub</a>.</li></ul><p>Vào Create chọn Create Automated Build, chọn Github rồi trỏ tới <a href=\"https://github.com/oNguyenVanHoan/docker_basic\">docker-basic</a> bạn vừa tạo ở GitHub.</p><figure class=\"image\"><img src=\"https://images.viblo.asia/641bcf0e-3829-4dea-8cae-66b2f9ef713e.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/641bcf0e-3829-4dea-8cae-66b2f9ef713e.png 2x\" sizes=\"100vw\"></figure><p>Và ta có <a href=\"https://hub.docker.com/r/hoanki/docker_basic\">docker_basic</a>, trông như sau:</p><figure class=\"image\"><img src=\"https://images.viblo.asia/0abebb83-b862-4e3c-a502-ee34e08399fd.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/0abebb83-b862-4e3c-a502-ee34e08399fd.png 2x\" sizes=\"100vw\"></figure><p>Dockerhub sẽ hỗ trợ bạn build docker image online, sau đó bạn có thể pull nó về để sử dụng.</p><p>Vào tab Build Settings,</p><figure class=\"image\"><img src=\"https://images.viblo.asia/3140301a-568d-4fc0-a310-3afb0cfb0236.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/3140301a-568d-4fc0-a310-3afb0cfb0236.png 2x\" sizes=\"100vw\"></figure><p>Từ giờ trở đi, mỗi khi bạn push code lên branch nào trên github branch đó bạn đã setting trên DockerHub thì images sẽ tự động được build.</p><p>Việc build này sẽ tự động thực hiên trên server Docker Hub nhé, ví dụ mình push code lên branch <code>init_dockerfile</code> thì Dockerhub tự động build image, kết quả có ở trong tab Build Detail.</p><p>Mình tạo <a href=\"https://github.com/oNguyenVanHoan/docker_basic/pull/1\">pull request</a>, sau khi mình merge nó thì DockerHub cũng sẽ build image tiếp trên branch master.</p><ul><li>Thử đi nhé, đôi khi buid ở local thì pass mà build trên server thì lỗi, cảm giác fix mãi nó mới hiện dòng chữ \"Success\" nó mới awesome làm sao.</li></ul><figure class=\"image\"><img src=\"https://images.viblo.asia/736bf541-8cc8-4d96-a905-49c32d315ea5.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/736bf541-8cc8-4d96-a905-49c32d315ea5.png 2x\" sizes=\"100vw\"></figure><h2 style=\"margin-left:0px;\"><strong>4. Docker compose</strong></h2><p>###############################################</p>','https://topdev.vn/blog/wp-content/uploads/2019/05/docker-banner.png','2021-04-20 21:53:16','2021-04-18 01:38:20',0,11),(12,'Docker: Chưa biết gì đến biết dùng (Phần 1- Lịch sử)','','<h2 style=\"margin-left:0px;\"><strong>1. Vì sao nên sử dụng</strong></h2><p>Vào một đêm đẹp trời <code>trăng thanh gió mát</code>,</p><p>Bạn được phân bổ vào dự án mới, và tất nhiên là hào khí <code>ngút trời</code>, thế như <code>chẻ tre</code></p><p>Hứng khởi vào đọc <code>README.md</code> một hồi, thấy dự án này sao mà cài cắm nhiều thứ thế</p><p>Nào là php, rồi npm, redis, mysql, elasticsearch, ...</p><p>Mỗi thứ lại phải kèm theo version bao nhiêu, một tá thư viện, vân vân và mây mây với với hàng tá thứ khác.</p><p>Định kể thêm tý nữa cho ra vẻ <code>nguy hiểm</code> nhưng mà thôi các bạn cứ hiểu là nhiều nhé</p><p>Lẩm bẩm một hồi, giờ ngồi search google, cài cắm một tá thứ này thì hết bao lâu ta ?</p><blockquote><p>Sếp ơi, em cần 1 buổi sáng để setup ạ.</p></blockquote><ul><li>Cài chưa xong đã thấy rối tùm lum, cái nọ xung đột cái kia chẳng hạn, lại còn ảnh hưởng tới những chương trình cũ đã cài đặt trong máy nữa chứ, thôi cài lại luôn cả hệ điều hành cho máy.</li></ul><blockquote><p>Sếp ơi, em cần thêm 1 buổi nữa để setup ạ -_-</p></blockquote><ul><li>Thôi xong, mất thời gian, mệt mỏi với nhưng thao tác phụ mà chưa tập trung được vào việc chính, hic.</li></ul><figure class=\"image\"><img src=\"https://viblo.asia/uploads/92a50912-d3dc-46db-9619-7b2495b2498f.jpg\" alt=\"\" srcset=\"https://viblo.asia/uploads/92a50912-d3dc-46db-9619-7b2495b2498f.jpg\" sizes=\"100vw\"></figure><ul><li>Đó chính là lúc bạn nên nghĩ tới Docker, mọi thứ sẽ đơn giản hơn nhiều.</li></ul><blockquote><p>Chỉ vài dòng lệnh thôi, cạch cạch cạch, bạn sẽ có thể nhanh chóng tạo được <code>môi trường ảo hóa</code> chứa đầy đủ những <code>cài đặt</code> cần thiết cho dự án rồi.</p></blockquote><ul><li>Một ví dụ đơn giản vậy thôi nhưng <code>không</code> dừng lại ở đó, công dụng của <code>Docker</code> còn khá nhiều, chúng ta cùng tìm hiểu dần nhé !</li></ul><h2 style=\"margin-left:0px;\"><strong>2. Quá trình hình thành</strong></h2><p>Trước hết, cùng đọc lịch sử một chút đã:</p><h3 style=\"margin-left:0px;\"><strong>2.1 Containerlization là gì ?</strong></h3><p>Ngày lâu lâu rồi, mô hình máy chủ thường là:</p><ul><li><code>Máy chủ vật lý (physical server)</code> + <code>hệ điều hành(operating system)</code> + <code>ứng dụng (application)</code>.</li><li>Vấn đề gặp phải ở đây là lãng phí tài nguyên<ul><li>Một máy chủ chỉ cài được một OS</li><li>Cho dù có ổ cứng khủng, ram khủng thì cũng không tận dụng hết lợi thế.</li></ul></li></ul><p>Sau đó ra đời công nghệ ảo hóa <code>virtualization</code>.</p><p>Có thể bạn đã nghe tới cái tên <code>Virtualbox</code> hay <code>VMware</code> rồi đúng không, đó đó chính nó đó.</p><p>Với công nghệ này, trên <code>một máy chủ vật lý</code> mình có thể cài đặt được <code>nhiều OS</code>, tận dụng tài nguyên đã tốt hơn.</p><figure class=\"image\"><img src=\"https://viblo.asia/uploads/f83e4a3a-bc95-4a4d-af37-dbaa9e03d28f.png\" alt=\"\" srcset=\"https://viblo.asia/uploads/f83e4a3a-bc95-4a4d-af37-dbaa9e03d28f.png\" sizes=\"100vw\"></figure><p>Ví dụ:</p><ul><li>Bạn đang cài đặt <code>Ubuntu</code> trên <code>máy tính</code> để lập trình, sau đó cài <code>VirtualBox</code> để có thể<ul><li>Cài thêm <code>Windows 10</code> - thi thoảng nhớ mùi còn vào <code>làm trận game</code>.</li><li>Cài thêm <code>CenOS</code> - thử trải nghiệm nhánh <code>RedHat</code> của họ nhà <code>Linux</code> xem sao do <code>Ubuntu</code> thuộc nhánh <code>Debian</code>.</li><li>Đó, vầy là trên một máy tính, bạn đã cài nhiều hệ điều hành để phục vụ cho những mục đích khác nhau.</li></ul></li></ul><p>Nhưng lại nảy sinh vấn đề tiếp.</p><p><code>Về tài nguyên</code>:</p><ul><li>Khi bạn bật máy ảo trên <code>VitualBox</code> chẳng hạn, bạn cần cấu hình để cung cấp ngay từ đầu tài nguyên <code>ổ cứng</code> và <code>ram</code> từ máy thật cho máy ảo.</li><li>Bật máy ảo lên rồi để đó không làm gì thì máy thật cũng không thể tái sử dụng tài nguyên đã cho đi.</li><li>Ví dụ khi tạo một <code>máy ảo ram 2GB</code> trên <code>máy thật ram 6GB</code>, lúc này máy thật sẽ chỉ còn <code>tối đa</code> 6 - 2 = 4 GB ram, kể cả khi máy ảo không dùng hết 2GB ram được cấp, đó là một sự <code>lãng phí</code>.</li></ul><p><code>Về thời gian</code>: Việc khởi động, tắt máy ảo khá lâu, có thể lên tới hàng phút.</p><p>Ở bước <code>tiến hóa</code> tiếp theo, người ta sinh ra công nghệ <code>containerlization</code></p><ul><li>Với công nghệ này, trên một máy chủ vật lý, ta sẽ cài đặt được nhiều máy ảo (giống với công nghệ ảo hóa <code>virtualization</code>), nhưng tốt hơn ở chỗ là các máy con này (Guess OS) đều <code>dùng chung</code> phần nhân của máy mẹ (Host OS) và chia sẻ với nhau tài nguyên máy mẹ.</li><li>Có thể nói là khi nào cần tài nguyên thì được cấp, cần bao nhiêu thì cấp bấy nhiêu, như vậy việc tận dụng tài nguyên đã tối ưu hơn. Điểm nổi bật nhất của <code>containerlization</code> là nó sử dụng các <code>container</code>, và một kĩ sư của Google đã phát biểu rằng:</li></ul><figure class=\"image\"><img src=\"https://viblo.asia/uploads/d68c3328-bfee-41a7-add0-6e38ed98f9f3.png\" alt=\"\" srcset=\"https://viblo.asia/uploads/d68c3328-bfee-41a7-add0-6e38ed98f9f3.png\" sizes=\"100vw\"></figure><p>Một công ty <code>hàng đầu</code> về công nghệ đã áp dụng nó, chứng tỏ lợi ích, độ tin cậy của công nghệ này rồi nhé ! Chúng ta cùng <code>áp dụng</code> nó thôi.</p><h3 style=\"margin-left:0px;\"><strong>2.2 Container là gì ?</strong></h3><p>Các phần mềm, chương trình sẽ được <code>Container Engine</code> ( là một công cụ ảo hóa tinh gọn được cài đặt trên host OS) đóng gói thành các <code>container</code>.</p><p>Thế <code>Container</code> là gì, nó là một giải pháp để <code>chuyển giao</code> phần mềm một cách đáng tin cậy giữa các <code>môi trường</code> máy tính khác nhau bằng cách:</p><ul><li>Tạo ra một môi trường chứa <code>mọi thứ</code> mà phần mềm cần để có thể chạy được.</li><li>Không bị các yếu tố liên quan đến môi trường <code>hệ thống</code> làm ảnh hưởng tới.</li><li>Cũng như không làm ảnh hưởng tới các phần còn lại của <code>hệ thống</code>.</li></ul><p>Bạn có thể hiểu là ruby, rails, mysql ... kia được bỏ gọn vào một hoặc nhiều cái thùng (container), ứng dụng của bạn chạy trong những chiếc thùng đó, đã có sẵn mọi thứ cần thiết để hoạt động, không bị ảnh hưởng từ bên ngoài và cũng không gây ảnh hưởng ra ngoài.</p><p>Các tiến trình (process) trong một <code>container</code> bị cô lập với các tiến trình của các container khác trong cùng hệ thống tuy nhiên tất cả các <code>container</code> này đều chia sẻ kernel của host OS (dùng chung host OS).</p><p>Đây một nền tảng mở dành cho các lập trình viên, quản trị hệ thống dùng để xây dựng, chuyển giao và chạy các ứng dụng <code>dễ dàng</code> hơn. Ví dụ, bạn có một app java, bạn sẽ <code>không cần</code> cài đặt JDK vào máy thật để chạy app đó, chỉ cần <code>kiếm</code> container đã được setting tương ứng cho app về, <code>bật</code> nó lên, cho app <code>chạy</code> bên trong môi trường container đó, vậy là ok. Khi không sài nữa thì <code>tắt hoặc xóa bỏ</code> container đó đi, không ảnh hưởng gì tới máy thật của bạn.</p><blockquote><p>Ưu điểm:</p></blockquote><ul><li><code>Linh động</code>: Triển khai ở bất kỳ nơi đâu do sự phụ thuộc của ứng dụng vào tầng OS cũng như cơ sở hạ tầng được loại bỏ.</li><li><code>Nhanh</code>: Do chia sẻ host OS nên container có thể được tạo gần như một cách tức thì. Điều này khác với vagrant - tạo môi trường ảo ở level phần cứng, nên khi khởi động mất nhiều thời gian hơn.</li><li><code>Nhẹ</code>: Container cũng sử dụng chung các images nên cũng không tốn nhiều disks.</li><li><code>Đồng nhất</code> :Khi nhiều người cùng phát triển trong cùng một dự án sẽ không bị sự sai khác về mặt môi trường.</li><li><code>Đóng gói</code>: Có thể ẩn môi trường bao gồm cả app vào trong một gói được gọi là container. Có thể test được các container. Việc bỏ hay tạo lại container rất dễ dàng.</li></ul><blockquote><p>Nhược điểm:</p></blockquote><p>Xét về tính <code>an toàn</code>:</p><ul><li>Do dùng chung OS nên nếu có lỗ hổng nào đấy ở kernel của host OS thì nó sẽ ảnh hưởng tới toàn bộ container có trong host OS đấy.</li><li>Ngoài ra hãy thử tưởng tượng với host OS là Linux, nếu trong trường hợp ai đấy hoặc một ứng dụng nào đấy có trong container chiếm được quyền superuser, điều gì sẽ xảy ra? Về lý thuyết thì tầng OS sẽ bị crack và ảnh hưởng trực tiếp tới máy host bị hack cũng như các container khác trong máy đó (hacker sử dụng quyền chiếm được để lấy dữ liệu từ máy host cũng như từ các container khác trong cùng máy host bị hack chẳng hạn).</li></ul><h3 style=\"margin-left:0px;\"><strong>2.3 Docker ra đời</strong></h3><p>Công nghệ ảo hóa (<code>virtualization</code>) thì ta có thể dùng công cụ Virtualbox hay VMware thế còn đối với <code>containerlization</code> thì dùng gì đây ? Google họ dùng gì ?</p><p>Oh mình không biết được, mỗi một ông lớn có một cách để áp dụng công nghệ này và họ <code>private</code> source code.</p><p>Gần đây, mà cũng lâu rồi&nbsp;</p><p>Có một công ty tiến hành <code>public</code> source code của họ về công nghệ này, họ tung ra sản phẩm mang tên là Docker và nhận được nhiều sự chú ý.</p><figure class=\"image\"><img src=\"https://viblo.asia/uploads/5b1bb3b4-f3b8-4183-853a-d11f0f4a4997.png\" alt=\"\" srcset=\"https://viblo.asia/uploads/5b1bb3b4-f3b8-4183-853a-d11f0f4a4997.png\" sizes=\"100vw\"></figure><p>Sau đó công ty cũng đổi tên thành Docker luôn. Công ty này cung cấp công cụ Docker free nhưng họ kiếm được rất nhiều tiền từ những dịch vụ khác đi kèm với nó.</p><p>Với sự bùng nổ của việc sử dụng <code>container</code> cùng với những lợi ích lớn mà nó mang lại, gã khổng lồ phần mềm <code>Microsoft</code> không muốn bỏ qua cơ hội màu mỡ này với việc cho ra mắt tính năng mới có tên <code>Windows Container</code>.</p><ul><li>Các bạn có thể tham khảo, áp dụng công cụ Windows Container của công ty Microsoft cho Windows tại <a href=\"https://docs.microsoft.com/en-us/virtualization/windowscontainers/about/\">đây</a>.</li><li>Còn phạm vi bài viết này xin giới hạn lại áp dụng sản phẩm Docker của công ty Docker cho Linux.</li></ul><blockquote><p><code>Đó, dân ta phải biết sử Tây là thế đó, chứ cứ lao vào học Docker luôn rồi cũng chẳng biết nó sinh đẻ thế nào, từ đâu mà ra, có anh em họ hàng gì không ?</code></p></blockquote><h2 style=\"margin-left:0px;\"><strong>3. Cài đặt ra sao ?</strong></h2><p><code>Docker</code> hỗ trợ nhiều nền tảng hệ điều hành khác nhau bao gồm <code>Linux</code>, <code>Windows</code> và cả <code>Mac</code>. Ngoài ra, Docker còn hỗ trợ nhiều <code>dịch vụ</code> điện toán đám mây nổi tiếng như Microsoft Azure hay Amazon Web Services.</p><p>Lưu ý là <code>ban đầu</code> nó được xây dựng trên nền tảng Linux. Vì Docker cần can thiệp vào <code>phần lõi</code>, nhân Kernel trong khí đó Linux là <code>mã nguồn mở</code>, gọi là cần gì có nấy.</p><p>Đến khi thấy Docker <code>hay quá</code>, bác Windows <code>ngỏ lời</code>, thế là công ty <code>Docker</code> và công ty <code>Microsoft</code> hợp tác với nhau nhưng nghe chừng <code>chưa khả quan</code> lắm bởi vì nhân Windows có nhưng thứ <code>không</code> public được ( bản quyền mà ).</p><p>Cho tới hiện tại khi <code>cài</code> Docker trên Windows hay Mac thì Docker sẽ cài một <code>máy ảo</code> Linux trên máy thật và Docker hoạt động <code>dựa trên</code> máy ảo Linux đó. Còn <code>tương lai</code> về sau thì ai biết được.</p><p>Docker có 2 phiên bản, CE( dành cho nhà phát triển, nhóm nhỏ, <code>coder</code> như chúng ta) và EE (dành cho <code>doanh nghiệp</code>).</p><p>Dưới đây mình sẽ giới thiệu cài đặt đối với bản <code>CE</code> trên <code>Ubuntu</code> thông qua <code>repository</code> như sau:</p><pre><code class=\"language-plaintext\">I. Chuẩn bị một chút:\n\n#### Update the apt package index:\n$ sudo apt-get update\n\n#### Install packages to allow apt to use a repository over HTTPS:\n$ sudo apt-get install \\\n   apt-transport-https \\\n   ca-certificates \\\n   curl \\\n   software-properties-common\n\n#### Add Docker’s official GPG key:\n$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n\n\n#### Verify that you now have the key with the fingerprint 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88, by searching for the last 8 characters of the fingerprint.\n$ sudo apt-key fingerprint 0EBFCD88\n\npub   4096R/0EBFCD88 2017-02-22\n     Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\nuid                  Docker Release (CE deb) &lt;docker@docker.com&gt;\nsub   4096R/F273FCD8 2017-02-22\n\n#### Use the following command to set up the stable repository\n$ sudo add-apt-repository \\\n    \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n    $(lsb_release -cs) \\\n    stable\"\n</code></pre><pre><code class=\"language-plaintext\">II. Cài đặt docker CE:\n\n#### Update the apt package index:\n$ sudo apt-get update\n\n#### Install the latest version of Docker CE, or go to the next step to install a specific version. Any existing installation of Docker is replaced.\n$ sudo apt-get install docker-ce\n\n#### Verify that Docker CE is installed correctly by running the hello-world image.\n$ sudo docker run hello-world\n</code></pre><ul><li>Nếu câu lệnh cuối cùng của bạn ra kết quả như sau thì bạn đã cài đặt Docker thành công:</li></ul><figure class=\"image\"><img src=\"https://images.viblo.asia/56651d41-4f39-45fb-bff7-615e0dc23381.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/56651d41-4f39-45fb-bff7-615e0dc23381.png 2x\" sizes=\"100vw\"></figure><p>Ngoài ra bạn có thể tham khảo cài đặt tại <a href=\"https://docs.docker.com/install\">trang chủ.</a></p><h2 style=\"margin-left:0px;\"><strong>4. Hoạt động như thế nào ?</strong></h2><ul><li><code>Docker image</code> là nền tảng của <code>container</code>, có thể hiểu Docker image như <code>khung xương</code> giúp định hình cho container, nó sẽ tạo ra container khi thực hiện <code>câu lệnh chạy</code> image đó. Nếu nói với phong cách <code>lập trình hướng đối tượng</code>, Docker image là <code>class</code>, còn container là <code>thực thể</code> (instance, thể hiện) của class đó.</li></ul><p>Docker có hai <code>khái niệm</code> chính cần hiểu, đó là <code>image</code> và <code>container</code>:</p><p><code>Container</code>: Tương tự như một <code>máy ảo</code>, xuất hiện khi mình <code>khởi chạy</code> image.</p><p><code>Tốc độ</code> khởi chạy container <code>nhanh hơn</code> tốc độ khởi chạy <code>máy ảo</code> rất nhiều và bạn có thể <code>thoải mái</code> chạy 4,5 container mà không sợ treo máy.</p><p>Các <code>files</code> và <code>settings</code> được sử dụng trong container được lưu, sử dụng lại, gọi chung là <code>images</code> của docker.</p><p><code>Image</code>: Tương tự như file <code>.gho</code> để ghost win mà mấy ông cài win dạo hay dùng.</p><p><code>Image</code> này không phải là một file vật lý mà nó chỉ được chứa trong Docker.</p><p>Một image bao gồm <code>hệ điều hành</code> (Windows, CentOS, Ubuntu, …) và các <code>môi trường</code> lập trình được cài sẵn (httpd, mysqld, nginx, python, git, …).</p><p><a href=\"https://hub.docker.com/\">Docker hub</a> là nơi lưu giữ và chia sẻ các file images này (hiện có khoảng 300.000 images)</p><p>Bạn có thể tìm tải các image mọi người chia sẻ sẵn trên mạng hoặc có thể tự tạo cho mình một cái image như ý.</p><h2 style=\"margin-left:0px;\"><strong>5. Các câu lệnh trong Docker</strong></h2><ul><li>Chuẩn chỉnh &amp; đầy đủ nhất thì bạn cứ tham khảo trên <a href=\"https://www.docker.com/\">trang chủ</a> của <a href=\"https://docs.docker.com/\">docker docs.</a> Còn ở bài viết này sẽ trích dẫn những câu lệnh cơ bản nhất giúp các bạn nhanh chóng nắm bắt:</li></ul><ol><li>Pull một image từ Docker Hub</li></ol><blockquote><p>sudo docker pull image_name</p></blockquote><ol><li>Tạo mới container bằng cách chạy image, kèm theo các tùy chọn:</li></ol><blockquote><p>sudo docker run -v &lt;forder_in_computer&gt;:&lt;forder_in_container&gt; -p &lt;port_in_computer&gt;:&lt;port_in_container&gt; -it &lt;image_name&gt; /bin/bash</p></blockquote><p>Ví dụ:</p><blockquote><p>sudo docker pull ubuntu:16.04</p><p>sudo docker run -it ubuntu:16.04 /bin/bash</p></blockquote><ul><li>Bây giờ bạn đã dựng thành công một môi trường ubuntu ảo rồi đó.</li></ul><p>Câu lệnh</p><blockquote><p><code>uname -a</code></p></blockquote><p>sẽ hiển thị thông tin của Kernel ubuntu, cùng so sánh nhé:</p><figure class=\"image\"><img src=\"https://images.viblo.asia/382e5fb7-12e4-4ca1-a954-1a41a7f77491.png\" alt=\"\" srcset=\"https://images.viblo.asia/retina/382e5fb7-12e4-4ca1-a954-1a41a7f77491.png 2x\" sizes=\"100vw\"></figure><p>Kết quả của dòng <code>uname-a</code> thứ nhất là thông tin Kernel của máy ảo (tức là của container)</p><blockquote><p>Linux 5ed7d9f282fe 4.15.0-36-generic #39~16.04.1-Ubuntu SMP Tue Sep 25 08:59:23 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</p></blockquote><p>Kết quả của dòng <code>uname-a</code> thứ hai là thông tin Kernel của máy \"thật\" (Linux) bạn đang dùng.</p><blockquote><p>Linux hoanki-Nitro-AN515-51 4.15.0-36-generic #39~16.04.1-Ubuntu SMP Tue Sep 25 08:59:23 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</p></blockquote><p>-&gt; Thông tin nhân Kernel như nhau nhé ! Do container sử dụng chung tài nguyên với host OS mà.</p><ul><li>Một vài câu lệnh khác:</li></ul><blockquote><p><code>docker images:</code> Liệt kê các images hiện có</p></blockquote><blockquote><p><code>docker rmi {image_id/name}:</code> Xóa một image</p></blockquote><blockquote><p><code>docker ps:</code> Liệt kê các container đang chạy</p></blockquote><blockquote><p><code>docker ps -a:</code> Liệt kê các container đã tắt</p></blockquote><blockquote><p><code>docker rm -f {container_id/name}:</code> Xóa một container</p></blockquote><blockquote><p><code>docker start {new_container_name}:</code> Khởi động một container</p></blockquote><blockquote><p><code>docker exec -it {new_container_name} /bin/bash:</code> Truy cập vào container đang chạy</p></blockquote><h2 style=\"margin-left:0px;\"><strong>6. Updating ...</strong></h2><p><code>Phần 1</code> này chủ yếu giới thiệu về <code>lý thuyết</code>, để mình cùng nhau <code>hiểu</code> Docker là gì và bản chất của Docker đã. Trong quá trình viết bài mình cần tìm hiểu thêm nhiều và cũng <code>nhận ra</code> nhiều điều mới. Nếu có ý kiến đóng góp gì, bạn vui lòng <code>comment</code> bên dưới nhé !</p><p>Trong phần 2 mình sẽ:</p><ul><li>Giải thích chi tiết hơn các câu lệnh (-it nghĩa là gì, /bin/bash nghĩa là gì,..)</li><li>Cách tạo Dockerfile</li><li>Cách tạo Docker Conpose, cấu hình,... Mời các bạn đón đọc.</li></ul>','https://topdev.vn/blog/wp-content/uploads/2019/05/docker-banner.png','2021-04-20 21:50:54','2021-04-18 01:40:14',0,11),(13,'Cách sử dụng từ khóa rethrows trong Swift','','### **1\\. Cách sử dụng từ khóa rethrows**\n\nTừ khóa rethrows được sử dụng trong các hàm không throw ra lỗi mà thay vào đó chuyển tiếp lỗi từ các hàm tham số của chúng. Nó cũng cho phép trình biên dịch chỉ yêu cầu từ khóa `try` nếu lệnh gọi lại đã cho thực sự gây ra lỗi.\n\nLấy ví dụ sau về một phương thức rethrowing thực hiện một cuộc gọi lại rethrowing :\n\n```plaintext\n func rethrowingFunction(throwingCallback: () throws -> Void) rethrows {\n     try throwingCallback()\n } \n```\n\nNếu lệnh gọi lại mà chúng ta chuyển vào không gây ra lỗi, chúng ta có thể gọi phương thức như sau:\n\n```plaintext\n rethrowingFunction {\n     print(\"I\'m not throwing errors\")\n } \n```\n\nTuy nhiên, ngay sau khi lệnh gọi lại của chúng ta có khả năng gây ra lỗi, trình biên dịch yêu cầu chúng ta sử dụng `try` cho phương thức rethrowing của chúng ta:\n\n![](https://images.viblo.asia/330dcbe1-6380-40f2-85d3-0cfffd559760.png)\n\nTrình biên dịch chỉ ra rằng phương thức rethrows của chúng ta không được đánh dấu bằng `try`\n\nĐiều này thật tuyệt vời vì nó cho phép chúng ta chỉ sử dụng từ khóa `try` nếu phần thân thực sự gặp lỗi. Không cần phải bao đóng phương thức của chúng ta trong một `try-catch` nếu nó không có khả năng nhận được lỗi.\n\nNếu chúng ta viết cùng một phương thức mà không có `rethrows`, chúng ta sẽ phải sử dụng `try` trong mọi trường hợp:\n\n```plaintext\n func rethrowingFunction(throwingCallback: () throws -> Void) throws {\n     try throwingCallback()\n }\n\n try rethrowingFunction {\n     print(\"I\'m not throwing errors\")\n } \n```\n\nNói cách khác, các phương thức rethrowing chỉ cần được đánh dấu bằng `try` nếu hàm tham số của chúng có khả năng gây ra lỗi.\n\n### **2\\. Một ví dụ trong trường hợp thực tế**\n\nBây giờ chúng ta đã biết cách hoạt động của từ khóa `rethrows`, chúng ta có thể xem một ví dụ trong trường hợp thực tế. Trong đoạn code sau, chúng ta đã tạo một phương thức bao đóng cho một mảng các string trong đó chúng ta nối các phần tử dựa trên một vị ngữ:\n\n```plaintext\n extension Array  where Self.Element == String {\n     func joined(separator: String, where predicate: (Element) throws -> Bool) rethrows {\n         try filter(predicate)\n             .joined(separator: separator)\n     }\n } \n```\n\nTheo mặc định, phương pháp `filter` tiêu chuẩn đang rethrow các lỗi. Tuy nhiên, nếu chúng ta muốn hưởng lợi từ hành vi này trong phương thức bao đóng `joined` của chúng ta, chúng ta cũng cần thực hiện phương thức rethrowing tùy chỉnh của mình. Nếu không, chúng ta sẽ không thể throw ra bất kỳ lỗi nào trong predicate của chúng ta.\n\nMột ví dụ sử dụng có thể trông như sau:\n\n```plaintext\n enum Error: Swift.Error {\n     case numbersNotAllowed\n }\n \n var names = [\"Light\", \"Near\", \"Eval\", \"Misa4\"]\n do {\n     try names.joined(separator: \", \", where: { name -> Bool in\n         guard name.rangeOfCharacter(from: .decimalDigits) == nil else {\n             throw Error.numbersNotAllowed\n         }\n         return true\n     })\n } catch {\n     print(error) // Prints: `numbersNotAllowed`\n } \n```\n\nVì chúng ta có một tên với số 4 trong đó, phương thức đã kết hợp sẽ gây ra lỗi.','https://www.crediblehost.co.zw/wp-content/uploads/2021/02/choosethebestbloggingplatform.png','2021-04-21 02:07:28','2021-04-19 11:43:00',1,11),(14,'Ngày đầu viết blog của Chung Chăm Chỉ','','<p>Hello, lần đầu tiên sau bao nhiêu ngày dự định viết blog. Hôm nay mới được viết !&nbsp;</p><p><strong>Cảm giác như nào nhỉ ?</strong></p><p>Từ ngày có kế hoạch fullstack tới giờ thì chắc bh mới có thể bước đầu thực hiện được. Cũng không có gì nhiều, cảm giác không khó để trở thành 1 fullstack lắm. &nbsp;</p><p>Chắc chắn là sẽ phải học thêm nhiều nữa. Những kiến thức liên quan tới optimize như webpack, purgecss, babel vẫn lơ tơ mơ chưa biết gì cả. Trong năm nay nhất định sẽ master cái đó. Cố lên nào!&nbsp;</p><figure class=\"image\"><img src=\"https://nhat.dev/wp-content/uploads/2020/01/Full-stack-developer-la-gi.jpg\" alt=\"\"><figcaption>I\'m going to become a full stack developer</figcaption></figure><p>Dự định sắp tới chắc mấy nữa xong con blog này phải lên kế hoạch thôi. Dạo này vào form rồi. Sáng 5h dậy, tối 11h đi ngủ. Nhưng mấy hôm nay đi ngủ hơi muộn nha! Từ mai sẽ không như thế nữa.&nbsp;</p><p>Sắp tới chắc sẽ chăm <mark class=\"marker-yellow\"><strong>đọc sách</strong></mark> hơn, đọc sách mới nhanh pro được. Cố gắng làm việc chăm chỉ. Mình sẽ làm 1 series riêng về việc đọc sách. Tới lúc ra trường sẽ có 1 kho tàng kiến thức từ việc đọc sách. Cố gắng mỗi tháng 1 quyển sách.</p><p>Trong tuần này làm Web Programming. Mỗi ngày mình sẽ cập nhật tiến độ tại đây. Sẽ xong trong tầm 2 tuần thôi. Còn dành thời gian cho môn khác. Đọc thêm kiến thức về backend. Cảm giác năm nay học được rất nhiều về Frontend, không còn cảm giác sợ UX như ngày trước nữa. Trình UX cũng được cải thiện hơn đáng kể. Nhưng vẫn cố gắng học hỏi từ các anh nhiều hơn nữa. Để còn nhanh Pro hơn.</p><p>Cố gắng học thêm về Product Thinking của các anh. Những cái đó không thể học được ở trên trường, mà lại là cái cần thiết và quyết định nhiều nhất tới sự sống còn của 1 sản phẩm.&nbsp;</p><p>Cố lên nào Chung Chăm Chỉ !</p><p>Thôi đi ngủ thôi mai còn dậy sớm.</p><blockquote><p style=\"text-align:center;\"><mark class=\"marker-yellow\">Today is a good day!</mark></p></blockquote>','https://www.trunghaile.com/2020/01/02/my-first-blog-post/featured.jpg','2021-04-20 21:46:59','2021-04-20 00:31:51',0,11),(15,'refactor api','','<p>1</p>','https://news.cloud365.vn/wp-content/uploads/2019/07/docker-compose.png','2021-04-21 01:45:28','2021-04-21 01:41:54',1,11),(16,'added all vegetable','','<p>121</p>','https://nukeviet.edu.vn/uploads/news/2021_01/1-tnsfds-deye722crqxjv8w.png','2021-04-21 01:45:22','2021-04-21 01:45:13',1,11),(17,'Ngày thứ 2 viết blog của chung chăm chỉ','','<h4>Hello everyone,</h4><p>Hôm nay là ngày viết blog thứ 2. Có vẻ hơi muộn nhỉ? Bây giờ đã là 2h đêm rồi. Hôm nay tại thằng Tùng qua chơi nên nhiều chuyện để hỏi quá.&nbsp;</p><p>Nào là chuyện về vấn đề Marketting, vấn đề suy nghĩ về sản phẩm, vấn đề về thuyết minh phim của mình liệu có thể đem đi bán lấy tiền được không. Cũng như các vấn đề về Ecommerce. Cũng nhiều cái cần nói quá nhi. Hehe</p><figure class=\"image\"><img src=\"https://taxplus.vn/wp-content/uploads/2019/11/e-commerce-la-gi-2.jpg\"><figcaption>Become Ecommerce Expert</figcaption></figure><p>Tối nay cũng hỏi được khá nhiều việc liên quan tới suy nghĩ của 1 đứa làm marketting, hiện đang làm lead của cả 1 công ty, những vấn đề mà nó gặp phải khi làm lead. Cũng khá là hay ho và đáng nhớ nè. Nhưng bị gấu giận mất rùi. Chả hiểu sao gấu giận mình nè. Chắc tại nói chuyện lâu quá. Tới hơn 12h mới nhắn tin lại cho gấu chó nè.&nbsp;</p><p>Chắc mai phải qua dỗ eny gấu rùi. Bây giờ đã 2h rồi chắc sáng mai 7h mới dậy được. Sáng mai dậy sẽ ngồi code backend cho web programming. Không thì không kịp xong trong tuần này mất.&nbsp;</p><p>Con Blog này chắc chạy ổn rồi. Có CRUB hết rồi. Chỉ thiếu 2 cái nữa thôi là có vẻ sẽ hoàn thiện được. À không. Hình như là 3 nè. Chúng ta sẽ phải làm thêm:</p><ul class=\"todo-list\"><li><label class=\"todo-list__label\"><input type=\"checkbox\" disabled=\"disabled\"><span class=\"todo-list__label__description\">&nbsp;Deploy lên server amazon</span></label></li><li><label class=\"todo-list__label\"><input type=\"checkbox\" disabled=\"disabled\"><span class=\"todo-list__label__description\">&nbsp;Thêm phần phân loại cho bài viết: Nhật ký, Blog công nghệ, cùng với đó là phân trang</span></label></li><li><label class=\"todo-list__label\"><input type=\"checkbox\" disabled=\"disabled\"><span class=\"todo-list__label__description\">&nbsp;Cuối cùng là thêm tag cho từng bài viết&nbsp;</span></label></li></ul><p>Cố gắng hoàn thành các phần việc trên sớm nhất có thể. Để có thể viết blog một cách mạch lạc hơn. Trước mắt là sẽ deploy lên amazon để có thể viết blog online trước đã. Sau đó là sẽ cải thiện thêm tính năng cho từng phần.</p><blockquote><p>Cố lên nào cho 1 blog hoàn thiện!</p></blockquote><h4>Còn vấn đề gì không nhỉ ?</h4><p>Ngày hôm này đi làm việc như thế nào ? Ồ nói chung là cũng không có gì đặc sắc. Lúc sáng chỉ ngồi viết lại libs và ngồi fix các lỗi vớ vẩn không phải của mình tạo ra. Thật là ngớ ngẩn quá đi nhỉ. Sẽ quyết tâm cải thiện để lần sau không như vậy nữa. Còn nhiều cái mình cần học hỏi quá đi.&nbsp;</p><p>Con đường phía trước còn rất dài và mình cần những mentor đủ giỏi để có thể dắt mình đi trong chặng đường sắp tới. Và mình tin chắc rằng những người anh ở công ty đủ tài năng và phẩm chất để giúp mình làm điều đó. Mình còn phải học thêm nhiều điều lắm!&nbsp;</p><blockquote><p>Cố lên nào Chung Chăm Chỉ ! Everything will be easy !&nbsp;</p></blockquote><p>Cố gắng lên nào. Mục tiêu ngày nào cũng viết nhật kí và blog nhé. Sau khi xong mấy con web này rồi sẽ ngồi đọc thêm về backend. Cho chỉnh chu hơn trong việc code. Chứ hiện tại cảm thấy đang code lung tung quá. Cố lên nào&nbsp;</p><p>Thôi đi ngủ thôi mai còn dậy sớm làm việc nữa. 7h dậy nha ! Cố lên nào. Ngủ thôi !&nbsp;</p>','http://static1.squarespace.com/static/538e7a53e4b0377ad0a3310d/54f52140e4b0d713c2424dd5/5698507d5a5668e07423f1f8/1452895061076/?format=1500w','2021-04-21 02:06:42','2021-04-21 01:58:24',0,11);
/*!40000 ALTER TABLE `article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `migrations`
--

DROP TABLE IF EXISTS `migrations`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `migrations` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `timestamp` bigint(20) NOT NULL,
  `name` varchar(255) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `migrations`
--

LOCK TABLES `migrations` WRITE;
/*!40000 ALTER TABLE `migrations` DISABLE KEYS */;
INSERT INTO `migrations` VALUES (9,1616162823072,'createUserTable1616162823072'),(10,1616165184964,'createArticlesTable1616165184964'),(14,1618682902840,'alterTableArticle1618682902840'),(16,1618684123258,'alterTableArticleUtf81618684123258'),(17,1618684492775,'alterTableArticleLongText1618684492775');
/*!40000 ALTER TABLE `migrations` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user`
--

DROP TABLE IF EXISTS `user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `avatar` varchar(255) DEFAULT NULL,
  `email` varchar(255) NOT NULL,
  `password` varchar(255) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `UQ_065d4d8f3b5adb4a08841eae3c8` (`name`),
  UNIQUE KEY `UQ_e12875dfb3b1d92d7d7c5377e22` (`email`)
) ENGINE=InnoDB AUTO_INCREMENT=126 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user`
--

LOCK TABLES `user` WRITE;
/*!40000 ALTER TABLE `user` DISABLE KEYS */;
INSERT INTO `user` VALUES (8,'Chung Chăm Chỉ 2',NULL,'dinhchungkhtnk292@gmail.com','$2b$10$E/ZRY9VjlJd/UmN2Jb5K9uIDH0I/WAe4xnYmqc5XqKEFov9FxwJMS'),(9,'Chung Chăm Chỉ 1',NULL,'dinhchungkhtnk291@gmail.com','$2b$10$9LBHkO2u57guDUo5..D6ouOc3gkCKHvtbtv/I0BFFg2OCiYjsuqUC'),(10,'Chung Dinh',NULL,'chungvuihaha@gmail.com','$2b$10$lTf3W75Qv2EI9z1aa7Jfle8BI7Np4yqJE2ysMoa5HNb4ajKqQ7qxe'),(11,'Chung Chăm Chỉ',NULL,'dinhchungkhtnk29@gmail.com','$2b$10$hXrS/YqRX2C1hc63xnILCeEnAIdMw/Q8CLntmhP.o51echA5MuEAK'),(97,'Pham Vui',NULL,'phamvui@gmail.com','$2b$10$usrpHn2gFn7kObvIqqLtV.U/6/qrjzWskpBrv.RYGh3q7SLejSZQ.'),(105,'Đinh Chung',NULL,'dinhchungkhtnk29121@gmail.com','$2b$10$eJX04Nv9IWcXUcettz7eI.0gMriXa7tJ8nLI09Wmo5o9kXsKKbw1K'),(120,'Đinh Chung 12',NULL,'phamvu12121i@gmail.com','$2b$10$EQxBI66svg5wOQrMES07wOccr/o6oEiPykuBR2DfHhr4G.8BpoYJy');
/*!40000 ALTER TABLE `user` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2021-04-21 12:50:00
